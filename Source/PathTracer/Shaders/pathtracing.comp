
#version 460

#extension GL_ARB_bindless_texture : require
#extension GL_ARB_gpu_shader_int64 : enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D imgOutput;

// --------------------------------------------------------

const float PI = 3.1415926f;
const float FLT_MAX = 3.402823466e+38f;

// --------------------------------------------------------

#define BVH_STACKSIZE 16

// --------------------------------------------------------

uniform mat4 ViewMatrix;
uniform mat4 ProjMatrix;
uniform mat4 InvProjMatrix;
uniform uint FrameCount;
uniform vec2 FrameDimensions;

uniform sampler2D PreviousPathTracingTexture;

// --------------------------------------------------------

struct Environment
{
	uint64_t HDRI;
	float skyRotationCos;
    float skyRotationSin;
};

struct Material
{
	// Texture handles
    uint64_t BaseColorTextureHandle;
    uint64_t NormalTextureHandle;
    uint64_t SpecularTextureHandle;
    uint64_t SpecularColorTextureHandle;
    uint64_t MetallicRoughnessTextureHandle;
    uint64_t SheenRoughnessTextureHandle;
    uint64_t SheenColorTextureHandle;
    uint64_t ClearcoatTextureHandle;
    uint64_t ClearcoatRoughnessTextureHandle;
    uint64_t ClearcoatNormalTextureHandle;
    uint64_t TransmissionTextureHandle;
    uint64_t EmissiveTextureHandle;

    // Attributes
    vec3 baseColor;
    float specular;
    vec3 specularColor;
    float metallic;
    float roughness;
    float subsurface;
    vec3 subsurfaceColor;
    float anisotropy;
    float sheenRoughness;
    vec3 sheenColor;
    float clearcoat;
    float clearcoatRoughness;
    float IOR;
    float transmission;
    vec3 emissiveColor;
};

struct BVHNode
{
	int left;   // Left subtree
    int right;  // Right subtree
    int n;      // Number of primitives
    int index;	// Primitive index
    vec3 AA;	// Bounding box AA
	vec3 BB;	// Bounding box BB
};

struct BVHPrimitive
{
	vec4 posAuvX;
	vec4 norAuvY;

	vec4 posBuvX;
	vec4 norBuvY;

	vec4 posCuvX;
	vec4 norCuvY;

	uint meshIndex;
};

// --------------------------------------------------------

layout(std430, binding = 0) readonly buffer EnvironmentBuffer
{
    Environment environment;
};

layout(std430, binding = 1) readonly buffer MaterialBuffer
{
    Material materials[];
};

layout(std430, binding = 2) readonly buffer BVHNodeBuffer
{
    BVHNode BVHNodes[];
};

layout(std430, binding = 3) readonly buffer BVHPrimitiveBuffer
{
    BVHPrimitive BVHPrimitives[];
};

// --------------------------------------------------------

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct HitInfo
{
	bool didHit;
	vec3 hitPoint;
	float dst;
	vec3 normal;
	vec2 uv;
	vec3 tangent;
	vec3 bitangent;
	Material material;
};

// Note: Triangle order matters! Must go counter-clock wise
// Calculate the intersection of a ray with a triangle using Möller–Trumbore algorithm
// Based on: https://stackoverflow.com/a/42752998
HitInfo RayTriangle(Ray ray, BVHPrimitive primitive)
{
	vec3 posA = primitive.posAuvX.xyz;
	vec3 posB = primitive.posBuvX.xyz;
	vec3 posC = primitive.posCuvX.xyz;

	vec3 norA = primitive.norAuvY.xyz;
	vec3 norB = primitive.norBuvY.xyz;
	vec3 norC = primitive.norCuvY.xyz;
	
	vec2 uvA = vec2(primitive.posAuvX.w, primitive.norAuvY.w);
	vec2 uvB = vec2(primitive.posBuvX.w, primitive.norBuvY.w);
	vec2 uvC = vec2(primitive.posCuvX.w, primitive.norCuvY.w);

	vec3 edgeAB = posB - posA;
	vec3 edgeAC = posC - posA;
	vec3 normalVector = cross(edgeAB, edgeAC);
	vec3 ao = ray.origin - posA;
	vec3 dao = cross(ao, ray.direction);

	float determinant = -dot(ray.direction, normalVector);
	float invDet = 1.0f / determinant;
	
	// Calculate dst to triangle & barycentric coordinates of intersection point
	float dst = dot(ao, normalVector) * invDet;
	float u = dot(edgeAC, dao) * invDet;
	float v = -dot(edgeAB, dao) * invDet;
	float w = 1.0f - u - v;
	
	// Initialize hit info
	HitInfo hitInfo;
	hitInfo.didHit = determinant >= 1e-10 && dst >= 0.0f && u >= 0.0f && v >= 0.0f && w >= 0.0f;
	hitInfo.hitPoint = ray.origin + ray.direction * dst;
	hitInfo.dst = dst;

	// Calculate normal and uv
	hitInfo.normal = normalize(norA * w + norB * u + norC * v);
	hitInfo.uv = uvA * w + uvB * u + uvC * v;

	// Calculate tangent and bitangent
	vec2 deltaUVB = uvB - uvA;
    vec2 deltaUVC = uvC - uvA;

    float invTangentDeterminant = 1.0f / (deltaUVB.x * deltaUVC.y - deltaUVB.y * deltaUVC.x);

    hitInfo.tangent = (edgeAB * deltaUVC.y - edgeAC * deltaUVB.y) * invTangentDeterminant;
    hitInfo.bitangent = (edgeAC * deltaUVB.x - edgeAB * deltaUVC.x) * invTangentDeterminant;

	return hitInfo;
}

// Return distance between ray and AABB box
float HitAABB(Ray r, vec3 AA, vec3 BB) 
{
    vec3 invdir = 1.0 / r.direction;

    vec3 f = (BB - r.origin) * invdir;
    vec3 n = (AA - r.origin) * invdir;

    vec3 tmax = max(f, n);
    vec3 tmin = min(f, n);

    float t1 = min(tmax.x, min(tmax.y, tmax.z));
    float t0 = max(tmin.x, max(tmin.y, tmin.z));

    return (t1 >= t0) ? ((t0 > 0.0) ? (t0) : (t1)) : (-1);
}

BVHPrimitive GetBVHPrimitive(int index)
{
	BVHPrimitive primitive = BVHPrimitives[index];
	return primitive;
}

Material GetMaterial(unsigned int index)
{
	Material material = materials[index];
	return material;
}

vec3 SampleNormalMap(sampler2D normalTexture, HitInfo hitInfo)
{
	vec3 N = hitInfo.normal;
	vec3 T = hitInfo.tangent;

	// Gram-Schmidt process: Re-orthogonalize T with respect to N
	T = normalize(T - dot(T, N) * N);

	// Recalculate bitangent due to Gram-Schmidt
	vec3 B = cross(N, T);

	// Create tangent space matrix
	// mat3 TBN = transpose(mat3(T, B, N)); // ???
	mat3 TBN = mat3(T, B, N);

	// Sample normal texture
	vec3 normalMap = texture(normalTexture, hitInfo.uv).rgb;

	// Transform normal vector to range [-1,1]
    normalMap = normalize(normalMap * 2.0 - 1.0);

	// Apply tangent space matrix
    normalMap = normalize(TBN * normalMap);

    return normalize(normalMap);
}

Material EvaluateMaterial(Material material, inout HitInfo hitInfo)
{
	Material evalutedMaterial = material;

	if (material.BaseColorTextureHandle != 0)
	{
		vec3 baseColorSample = texture(sampler2D(material.BaseColorTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.baseColor *= baseColorSample;
	}

	if (material.NormalTextureHandle != 0)
	{
		hitInfo.normal = SampleNormalMap(sampler2D(material.NormalTextureHandle), hitInfo);
//		evalutedMaterial.baseColor = hitInfo.normal;
	}

	if (material.SpecularTextureHandle != 0)
	{
		float specularSample = texture(sampler2D(material.SpecularTextureHandle), hitInfo.uv).a;
		evalutedMaterial.specular *= specularSample;
	}

	if (material.SpecularColorTextureHandle != 0)
	{
		vec3 specularColorSample = texture(sampler2D(material.SpecularColorTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.specularColor *= specularColorSample;
	}

	if (material.MetallicRoughnessTextureHandle != 0)
	{
		vec2 metallicRoughnessSample = texture(sampler2D(material.MetallicRoughnessTextureHandle), hitInfo.uv).rg;
		evalutedMaterial.metallic *= metallicRoughnessSample.x;
		evalutedMaterial.roughness *= metallicRoughnessSample.y;
	}

	if (material.SheenRoughnessTextureHandle != 0)
	{
		float sheenRoughnessSample = texture(sampler2D(material.SheenRoughnessTextureHandle), hitInfo.uv).a;
		evalutedMaterial.sheenRoughness *= sheenRoughnessSample;
	}

	if (material.SheenColorTextureHandle != 0)
	{
		vec3 sheenColorSample = texture(sampler2D(material.SheenColorTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.sheenColor *= sheenColorSample;
	}

	if (material.ClearcoatTextureHandle != 0)
	{
		float clearcoatSample = texture(sampler2D(material.ClearcoatTextureHandle), hitInfo.uv).r;
		evalutedMaterial.clearcoat *= clearcoatSample;
	}

	if (material.ClearcoatRoughnessTextureHandle != 0)
	{
		float clearcoatRoughnessSample = texture(sampler2D(material.ClearcoatRoughnessTextureHandle), hitInfo.uv).g;
		evalutedMaterial.clearcoatRoughness *= clearcoatRoughnessSample;
	}

	// ???
	//	if (material.ClearcoatNormalTextureHandle != 0)
	//	{
	//		evalutedMaterial.clearcoat = texture(sampler2D(material.ClearcoatNormalTextureHandle), hitInfo.uv).rgb;
	//	}

	if (material.TransmissionTextureHandle != 0)
	{
		float transmissionSample = texture(sampler2D(material.TransmissionTextureHandle), hitInfo.uv).r;
		evalutedMaterial.transmission *= transmissionSample;
	}

	if (material.EmissiveTextureHandle != 0)
	{
		vec3 emissiveColorSample = texture(sampler2D(material.EmissiveTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.emissiveColor *= emissiveColorSample;
	}

	return evalutedMaterial;
}

HitInfo HitArray(Ray ray, int L, int R)
{
	HitInfo closestHit;
	closestHit.didHit = false;
	closestHit.dst = FLT_MAX;

	for (int i = L; i <= R; i++)
	{
		BVHPrimitive primitive = GetBVHPrimitive(i);
		HitInfo hitInfo = RayTriangle(ray, primitive);

		if (hitInfo.didHit && hitInfo.dst < closestHit.dst)
		{
			closestHit = hitInfo;
			
			Material currentMaterial = GetMaterial(primitive.meshIndex);
			Material evaluatedMaterial = EvaluateMaterial(currentMaterial, hitInfo);

			closestHit.material = evaluatedMaterial;
		}
	}

	return closestHit;
}

BVHNode GetBVHNode(int index)
{
	BVHNode node = BVHNodes[index];
	return node;
}

HitInfo HitBVH(Ray ray)
{
	HitInfo closestHit;
	closestHit.didHit = false;
	closestHit.dst = FLT_MAX;

	// Stack
	int stack[BVH_STACKSIZE];
	int stackPointer = 0;

	stack[stackPointer++] = 1;
	while(stackPointer > 0)
	{
		int top = stack[--stackPointer];
		BVHNode node = GetBVHNode(top);

		// If node is leaf, traverse primitives and find intersection
		if (node.n > 0)
		{
			int L = node.index;
			int R = node.index + node.n - 1;

			// Go through all primitives inside of BVH node range
			HitInfo hitInfo = HitArray(ray, L, R);
			
			// Out of the other nodes, did this one perform better?
			if (hitInfo.didHit && hitInfo.dst < closestHit.dst)
			{
				closestHit = hitInfo;
			}
		}
		else
		{
			if (stackPointer < BVH_STACKSIZE)
			{
				// Find intersection with left and right boxes AABB
				float dstLeft = FLT_MAX;
				float dstRight = FLT_MAX;

				if (node.left > 0.0f)
				{
					BVHNode leftNode = GetBVHNode(node.left);
					dstLeft = HitAABB(ray, leftNode.AA, leftNode.BB);
				}

				if (node.right > 0.0f)
				{
					BVHNode rightNode = GetBVHNode(node.right);
					dstRight = HitAABB(ray, rightNode.AA, rightNode.BB);
				}

				// Search in recent boxes
				if (dstLeft > 0.0f && dstRight > 0.0f)
				{
					if (dstLeft < dstRight)
					{
						// Left first
						stack[stackPointer++] = node.right;
						stack[stackPointer++] = node.left;
					}
					else
					{
						// Right first
						stack[stackPointer++] = node.left;
						stack[stackPointer++] = node.right;
					}
				}
				else if (dstLeft > 0.0f)
				{
					stack[stackPointer++] = node.left;
				}
				else if (dstRight > 0.0f)
				{
					stack[stackPointer++] = node.right;
				}
			}
			else
			{
				break;
			}
		}
	}

	return closestHit;
}

vec3 HitBVHDebug(Ray ray)
{
	uint hitCounter = 0;

	// Stack
	int stack[BVH_STACKSIZE];
	int stackPointer = 0;

	stack[stackPointer++] = 1;
	while(stackPointer > 0)
	{
		int top = stack[--stackPointer];
		BVHNode node = GetBVHNode(top);

		// If node is leaf, traverse primitives and find intersection
		if (node.n > 0)
		{
			hitCounter++;
		}
		else
		{
			if (stackPointer < BVH_STACKSIZE)
			{
				// Find intersection with left and right boxes AABB
				float dstLeft = FLT_MAX;
				float dstRight = FLT_MAX;

				if (node.left > 0.0f)
				{
					BVHNode leftNode = GetBVHNode(node.left);
					dstLeft = HitAABB(ray, leftNode.AA, leftNode.BB);
				}

				if (node.right > 0.0f)
				{
					BVHNode rightNode = GetBVHNode(node.right);
					dstRight = HitAABB(ray, rightNode.AA, rightNode.BB);
				}

				// Search in recent boxes
				if (dstLeft > 0.0f && dstRight > 0.0f)
				{
					if (dstLeft < dstRight)
					{
						// Left first
						stack[stackPointer++] = node.right;
						stack[stackPointer++] = node.left;
					}
					else
					{
						// Right first
						stack[stackPointer++] = node.left;
						stack[stackPointer++] = node.right;
					}
				}
				else if (dstLeft > 0.0f)
				{
					stack[stackPointer++] = node.left;
				}
				else if (dstRight > 0.0f)
				{
					stack[stackPointer++] = node.right;
				}
			}
			else
			{
				hitCounter = 0xFFFFFFFF;
				break;
			}
		}
	}

	if (hitCounter == 0xFFFFFFFF)
	{
		return vec3(1.0f, 0.0f, 1.0f); // error: stack overflow (purple)
	}

	// Heat map
	const vec3 mapTex[] = {
		vec3(0.0f, 0.0f, 0.0f),
		vec3(0.0f, 0.0f, 1.0f),
		vec3(0.0f, 1.0f, 1.0f),
		vec3(0.0f, 1.0f, 0.0f),
		vec3(1.0f, 1.0f, 0.0f),
		vec3(1.0f, 0.0f, 0.0f),
	};

	const float mapTexLen = 5.0f;
	const float maxHeat = 100.0f;
	float l = clamp(float(hitCounter) / maxHeat, 0.0f, 1.0f) * mapTexLen;
	vec3 a = mapTex[uint(floor(l))];
	vec3 b = mapTex[uint(ceil(l))];
	vec3 heatmap = mix(a, b, l - floor(l));

	return heatmap;
}

// PCG (permuted congruential generator). Thanks to:
// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint NextRandom(inout uint state)
{
	state = state * 747796405 + 2891336453;
	uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
	result = (result >> 22) ^ result;
	return result;
}

float RandomValue(inout uint state)
{
	return NextRandom(state) / 4294967295.0f; // 2^32 - 1
}

// Random value in normal distribution (with mean=0 and sd=1)
float RandomValueNormalDistribution(inout uint state)
{
	// Thanks to https://stackoverflow.com/a/6178290
	float theta = 2.0f * PI * RandomValue(state);
	float rho = sqrt(-2.0f * log(RandomValue(state)));
	return rho * cos(theta);
}

// Calculate a random direction
vec3 RandomDirection(inout uint state)
{
	// Thanks to https://math.stackexchange.com/a/1585996
	float x = RandomValueNormalDistribution(state);
	float y = RandomValueNormalDistribution(state);
	float z = RandomValueNormalDistribution(state);
	return normalize(vec3(x, y, z));
}

vec3 GetEnvironmentLight(Ray ray)
{
	vec3 V = ray.direction;

	mat2x2 rot = mat2x2(
		environment.skyRotationCos, -environment.skyRotationSin,
		environment.skyRotationSin, environment.skyRotationCos
	);
	V.xz = V.xz * rot;

	vec2 uv = (vec2(-atan(V.z, V.x) / PI, -V.y) + 1.0f) * 0.5f;
	return texture(sampler2D(environment.HDRI), uv).rgb;
}

vec3 Trace(Ray ray, inout uint rngState)
{
	vec3 incomingLight = vec3(0.0f);
	vec3 rayColor = vec3(1.0f);

	const uint MaxBounceCount = 1;
	for (uint i = 0; i <= MaxBounceCount; i++)
	{
		HitInfo hitInfo = HitBVH(ray);
		if (hitInfo.didHit)
		{
			ray.origin = hitInfo.hitPoint;
			ray.direction = normalize(hitInfo.normal + RandomDirection(rngState));

			Material material = hitInfo.material;
			rayColor *= material.baseColor;

			// Random early exit if ray colour is nearly 0 (can't contribute much to final result)
			float p = max(rayColor.r, max(rayColor.g, rayColor.b));
			if (RandomValue(rngState) >= p) 
			{
				break;
			}
			rayColor *= 1.0f / p;
		}
		else
		{
			incomingLight += GetEnvironmentLight(ray) * rayColor;
			break;
		}
	}

	return incomingLight;
}

void main()
{
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (texelCoord + 0.5f) / FrameDimensions;

	uint pixelIndex = texelCoord.y * uint(FrameDimensions.x) + texelCoord.x;
	uint rngState = pixelIndex + FrameCount * 719393;

	// Start from transformed position
	vec4 viewPos = InvProjMatrix * vec4(uv * 2.0f - 1.0f, 0.0f, 1.0f);
	vec3 origin = viewPos.xyz / viewPos.w;
	vec3 dir = normalize(origin); // Normalize to get view direction

	// Ray
	Ray ray;
	ray.origin = (inverse(ViewMatrix) * vec4(origin, 1)).xyz;
	ray.direction = (inverse(ViewMatrix) * vec4(dir, 0)).xyz;

	// Debug BVH
#if 0
	vec3 debug = HitBVHDebug(ray);
	vec4 debugValue = vec4(debug, 1.0f);

	imageStore(imgOutput, texelCoord, debugValue);
	return;
#endif

	// RayTrace 
	vec3 totalIncomingLight = vec3(0.0f);
	const uint NumRaysPerPixel = 1;
	for (uint rayIndex = 0; rayIndex < NumRaysPerPixel; rayIndex++)
	{
		totalIncomingLight += Trace(ray, rngState);
	}
	vec3 result = totalIncomingLight / float(NumRaysPerPixel);

	vec3 currentColor = result;
	vec3 previousColor = texelFetch(PreviousPathTracingTexture, texelCoord, 0).rgb;
	
	// Combine prev frame with current frame. Weight the contributions to result in an average over all frames.
	float weight = 1.0f / FrameCount;
	vec3 accumulatedColor = clamp(previousColor * (1 - weight) + currentColor * weight, 0.0f, 1.0f);
	
	// Value
	vec4 value = vec4(accumulatedColor, 1.0f);

//	HitInfo hitInfo = HitBVH(ray);
//	vec4 value = vec4(hitInfo.didHit);
//	HitInfo hitInfo = HitArray(ray, 0, BVHPrimitives.length() - 1);
//	vec4 value = vec4(hitInfo.didHit);

//	HitInfo hitInfo = HitBVH(ray);
//
//	Material material = GetMaterial(0);
//	hitInfo.normal = SampleNormalMap(sampler2D(material.NormalTextureHandle), hitInfo);
//
//	vec4 value = vec4(float(hitInfo.didHit) * hitInfo.normal, 1.0f);

	imageStore(imgOutput, texelCoord, value);
}
