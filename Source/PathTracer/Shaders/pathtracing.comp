
#version 460

#extension GL_ARB_bindless_texture : require
#extension GL_ARB_gpu_shader_int64 : enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D primaryBaseColorOutput;
layout(rgba32f, binding = 1) uniform image2D primaryNormalOutput;
layout(rgba32f, binding = 2) uniform image2D accumulationOutput;

// --------------------------------------------------------

uniform mat4 ViewMatrix;
uniform mat4 ProjMatrix;
uniform mat4 InvProjMatrix;
uniform uint FrameCount;
uniform vec2 FrameDimensions;
uniform float FocalLength;
uniform float ApertureSize;
uniform vec2 ApertureShape;
uniform float DebugValueA;
uniform float DebugValueB;

uniform sampler2D PreviousAccumulationTexture;

// --------------------------------------------------------

const float PI = 3.1415926f;
const float FLT_MAX = 3.402823466e+38f;

#define BVH_STACKSIZE 16

// --------------------------------------------------------

//#define DEBUG_HDRI_CACHE
//#define DEBUG_BVH

#if defined(DEBUG_HDRI_CACHE) || defined(DEBUG_BVH)
#define DEBUG_ENABLED
#endif

// --------------------------------------------------------

struct Settings
{
	float debugValueA;
	float debugValueB;
};

struct Environment
{
	uint64_t HDRI;
	uint64_t HDRICache;
	vec2 HDRIDimensions;
};

struct Material
{
    uint64_t BaseColorTextureHandle;
    uint64_t NormalTextureHandle;
    uint64_t SpecularTextureHandle;
    uint64_t SpecularColorTextureHandle;
    uint64_t MetallicRoughnessTextureHandle;
    uint64_t SheenRoughnessTextureHandle;
    uint64_t SheenColorTextureHandle;
    uint64_t ClearcoatTextureHandle;
    uint64_t ClearcoatRoughnessTextureHandle;
    uint64_t ClearcoatNormalTextureHandle;
    uint64_t TransmissionTextureHandle;
    uint64_t EmissiveTextureHandle;

    vec3 baseColor;
    float specular;
    vec3 specularColor;
    float metallic;
    float roughness;
    float subsurface;
    vec3 subsurfaceColor;
    float anisotropy;
    float sheenRoughness;
    vec3 sheenColor;
    float clearcoat;
    float clearcoatRoughness;
    float refraction;
    float transmission;
    vec3 emissiveColor;
};

struct BVHNode
{
	int left;   // Left subtree
    int right;  // Right subtree
    int n;      // Number of primitives
    int index;	// Primitive index
    vec3 AA;	// Bounding box AA
	vec3 BB;	// Bounding box BB
};

struct BVHPrimitive
{
	vec4 posAuvX;
	vec4 norAuvY;

	vec4 posBuvX;
	vec4 norBuvY;

	vec4 posCuvX;
	vec4 norCuvY;

	uint meshIndex;
};

// --------------------------------------------------------

layout(std430, binding = 0) readonly buffer SettingsBuffer
{
    Settings settings;
};

layout(std430, binding = 1) readonly buffer EnvironmentBuffer
{
    Environment environment;
};

layout(std430, binding = 2) readonly buffer MaterialBuffer
{
    Material materials[];
};

layout(std430, binding = 3) readonly buffer BVHNodeBuffer
{
    BVHNode BVHNodes[];
};

layout(std430, binding = 4) readonly buffer BVHPrimitiveBuffer
{
    BVHPrimitive BVHPrimitives[];
};

// --------------------------------------------------------

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct HitInfo
{
	bool didHit;
	vec3 hitPoint;
	vec3 hitDirection;
	float dst;
	vec3 normal;
	vec2 uv;
	vec3 tangent;
	vec3 bitangent;
	Material material;
};

// --------------------------------------------------------

// Note: Triangle order matters! Must go counter-clock wise
// Calculate the intersection of a ray with a triangle using Möller–Trumbore algorithm
// Based on: https://stackoverflow.com/a/42752998
HitInfo RayTriangle(Ray ray, BVHPrimitive primitive)
{
	vec3 posA = primitive.posAuvX.xyz;
	vec3 posB = primitive.posBuvX.xyz;
	vec3 posC = primitive.posCuvX.xyz;

	vec3 norA = primitive.norAuvY.xyz;
	vec3 norB = primitive.norBuvY.xyz;
	vec3 norC = primitive.norCuvY.xyz;
	
	vec2 uvA = vec2(primitive.posAuvX.w, primitive.norAuvY.w);
	vec2 uvB = vec2(primitive.posBuvX.w, primitive.norBuvY.w);
	vec2 uvC = vec2(primitive.posCuvX.w, primitive.norCuvY.w);

	vec3 edgeAB = posB - posA;
	vec3 edgeAC = posC - posA;
	vec3 normalVector = cross(edgeAB, edgeAC);
	vec3 ao = ray.origin - posA;
	vec3 dao = cross(ao, ray.direction);

	float determinant = -dot(ray.direction, normalVector);
	float invDet = 1.0f / determinant;
	
	// Calculate dst to triangle & barycentric coordinates of intersection point
	float dst = dot(ao, normalVector) * invDet;
	float u = dot(edgeAC, dao) * invDet;
	float v = -dot(edgeAB, dao) * invDet;
	float w = 1.0f - u - v;
	
	// Initialize hit info
	HitInfo hitInfo;
	hitInfo.didHit = determinant >= 1e-10 && dst >= 0.0f && u >= 0.0f && v >= 0.0f && w >= 0.0f;
	hitInfo.hitPoint = ray.origin + ray.direction * dst;
	hitInfo.hitDirection = ray.direction;
	hitInfo.dst = dst;

	// Calculate normal and uv
	hitInfo.normal = normalize(norA * w + norB * u + norC * v);
	hitInfo.uv = uvA * w + uvB * u + uvC * v;

	// Calculate tangent and bitangent
	vec2 deltaUVB = uvB - uvA;
    vec2 deltaUVC = uvC - uvA;

    float invTangentDeterminant = 1.0f / (deltaUVB.x * deltaUVC.y - deltaUVB.y * deltaUVC.x);

    hitInfo.tangent = (edgeAB * deltaUVC.y - edgeAC * deltaUVB.y) * invTangentDeterminant;
    hitInfo.bitangent = (edgeAC * deltaUVB.x - edgeAB * deltaUVC.x) * invTangentDeterminant;

	return hitInfo;
}

// Return distance between ray and AABB box
float HitAABB(Ray r, vec3 AA, vec3 BB) 
{
    vec3 invdir = 1.0 / r.direction;

    vec3 f = (BB - r.origin) * invdir;
    vec3 n = (AA - r.origin) * invdir;

    vec3 tmax = max(f, n);
    vec3 tmin = min(f, n);

    float t1 = min(tmax.x, min(tmax.y, tmax.z));
    float t0 = max(tmin.x, max(tmin.y, tmin.z));

    return (t1 >= t0) ? ((t0 > 0.0) ? (t0) : (t1)) : (-1);
}

// --------------------------------------------------------

vec3 SampleNormalMap(sampler2D normalTexture, HitInfo hitInfo)
{
	vec3 N = hitInfo.normal;
	vec3 T = hitInfo.tangent;

	// Gram-Schmidt process: Re-orthogonalize T with respect to N
	T = normalize(T - dot(T, N) * N);

	// Recalculate bitangent due to Gram-Schmidt
	vec3 B = cross(N, T);

	// Create tangent space matrix
	// mat3 TBN = transpose(mat3(T, B, N)); // ???
	mat3 TBN = mat3(T, B, N);

	// Sample normal texture
	vec3 normalMap = texture(normalTexture, hitInfo.uv).rgb;

	// Transform normal vector to range [-1,1]
    normalMap = normalize(normalMap * 2.0 - 1.0);

	// Apply tangent space matrix
    normalMap = normalize(TBN * normalMap);

    return normalize(normalMap);
}

Material EvaluateMaterial(Material material, inout HitInfo hitInfo)
{
	Material evalutedMaterial = material;

	if (material.BaseColorTextureHandle != 0)
	{
		vec3 baseColorSample = texture(sampler2D(material.BaseColorTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.baseColor *= baseColorSample;
	}

	if (material.NormalTextureHandle != 0)
	{
		hitInfo.normal = SampleNormalMap(sampler2D(material.NormalTextureHandle), hitInfo);
//		evalutedMaterial.baseColor = hitInfo.normal;
	}

	if (material.SpecularTextureHandle != 0)
	{
		float specularSample = texture(sampler2D(material.SpecularTextureHandle), hitInfo.uv).a;
		evalutedMaterial.specular *= specularSample;
	}

	if (material.SpecularColorTextureHandle != 0)
	{
		vec3 specularColorSample = texture(sampler2D(material.SpecularColorTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.specularColor *= specularColorSample;
	}

	if (material.MetallicRoughnessTextureHandle != 0)
	{
		vec2 metallicRoughnessSample = texture(sampler2D(material.MetallicRoughnessTextureHandle), hitInfo.uv).rg;
		evalutedMaterial.metallic *= metallicRoughnessSample.x;
		evalutedMaterial.roughness *= metallicRoughnessSample.y;
	}

	if (material.SheenRoughnessTextureHandle != 0)
	{
		float sheenRoughnessSample = texture(sampler2D(material.SheenRoughnessTextureHandle), hitInfo.uv).a;
		evalutedMaterial.sheenRoughness *= sheenRoughnessSample;
	}

	if (material.SheenColorTextureHandle != 0)
	{
		vec3 sheenColorSample = texture(sampler2D(material.SheenColorTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.sheenColor *= sheenColorSample;
	}

	if (material.ClearcoatTextureHandle != 0)
	{
		float clearcoatSample = texture(sampler2D(material.ClearcoatTextureHandle), hitInfo.uv).r;
		evalutedMaterial.clearcoat *= clearcoatSample;
	}

	if (material.ClearcoatRoughnessTextureHandle != 0)
	{
		float clearcoatRoughnessSample = texture(sampler2D(material.ClearcoatRoughnessTextureHandle), hitInfo.uv).g;
		evalutedMaterial.clearcoatRoughness *= clearcoatRoughnessSample;
	}

	// ???
	//	if (material.ClearcoatNormalTextureHandle != 0)
	//	{
	//		evalutedMaterial.clearcoat = texture(sampler2D(material.ClearcoatNormalTextureHandle), hitInfo.uv).rgb;
	//	}

	if (material.TransmissionTextureHandle != 0)
	{
		float transmissionSample = texture(sampler2D(material.TransmissionTextureHandle), hitInfo.uv).r;
		evalutedMaterial.transmission *= transmissionSample;
	}

	if (material.EmissiveTextureHandle != 0)
	{
		vec3 emissiveColorSample = texture(sampler2D(material.EmissiveTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.emissiveColor *= emissiveColorSample;
	}

	return evalutedMaterial;
}

// --------------------------------------------------------

BVHPrimitive GetBVHPrimitive(int index)
{
	BVHPrimitive primitive = BVHPrimitives[index];
	return primitive;
}

Material GetMaterial(unsigned int index)
{
	Material material = materials[index];
	return material;
}

HitInfo HitArray(Ray ray, int L, int R)
{
	HitInfo closestHit;
	closestHit.didHit = false;
	closestHit.dst = FLT_MAX;

	for (int i = L; i <= R; i++)
	{
		BVHPrimitive primitive = GetBVHPrimitive(i);
		HitInfo hitInfo = RayTriangle(ray, primitive);

		if (hitInfo.didHit && hitInfo.dst < closestHit.dst)
		{
			closestHit = hitInfo;
			
			Material currentMaterial = GetMaterial(primitive.meshIndex);
			Material evaluatedMaterial = EvaluateMaterial(currentMaterial, hitInfo);

			closestHit.material = evaluatedMaterial;
		}
	}

	return closestHit;
}

BVHNode GetBVHNode(int index)
{
	BVHNode node = BVHNodes[index];
	return node;
}

HitInfo HitBVH(Ray ray)
{
	HitInfo closestHit;
	closestHit.didHit = false;
	closestHit.dst = FLT_MAX;

	// Stack
	int stack[BVH_STACKSIZE];
	int stackPointer = 0;

	stack[stackPointer++] = 1;
	while(stackPointer > 0)
	{
		int top = stack[--stackPointer];
		BVHNode node = GetBVHNode(top);

		// If node is leaf, traverse primitives and find intersection
		if (node.n > 0)
		{
			int L = node.index;
			int R = node.index + node.n - 1;

			// Go through all primitives inside of BVH node range
			HitInfo hitInfo = HitArray(ray, L, R);
			
			// Out of the other nodes, did this one perform better?
			if (hitInfo.didHit && hitInfo.dst < closestHit.dst)
			{
				closestHit = hitInfo;
			}
		}
		else
		{
			if (stackPointer < BVH_STACKSIZE)
			{
				// Find intersection with left and right boxes AABB
				float dstLeft = FLT_MAX;
				float dstRight = FLT_MAX;

				if (node.left > 0.0f)
				{
					BVHNode leftNode = GetBVHNode(node.left);
					dstLeft = HitAABB(ray, leftNode.AA, leftNode.BB);
				}

				if (node.right > 0.0f)
				{
					BVHNode rightNode = GetBVHNode(node.right);
					dstRight = HitAABB(ray, rightNode.AA, rightNode.BB);
				}

				// Search in recent boxes
				if (dstLeft > 0.0f && dstRight > 0.0f)
				{
					if (dstLeft < dstRight)
					{
						// Left first
						stack[stackPointer++] = node.right;
						stack[stackPointer++] = node.left;
					}
					else
					{
						// Right first
						stack[stackPointer++] = node.left;
						stack[stackPointer++] = node.right;
					}
				}
				else if (dstLeft > 0.0f)
				{
					stack[stackPointer++] = node.left;
				}
				else if (dstRight > 0.0f)
				{
					stack[stackPointer++] = node.right;
				}
			}
			else
			{
				break;
			}
		}
	}

	return closestHit;
}

vec3 HitBVHDebug(Ray ray)
{
	uint hitCounter = 0;

	// Stack
	int stack[BVH_STACKSIZE];
	int stackPointer = 0;

	stack[stackPointer++] = 1;
	while(stackPointer > 0)
	{
		int top = stack[--stackPointer];
		BVHNode node = GetBVHNode(top);

		// If node is leaf, traverse primitives and find intersection
		if (node.n > 0)
		{
			hitCounter++;
		}
		else
		{
			if (stackPointer < BVH_STACKSIZE)
			{
				// Find intersection with left and right boxes AABB
				float dstLeft = FLT_MAX;
				float dstRight = FLT_MAX;

				if (node.left > 0.0f)
				{
					BVHNode leftNode = GetBVHNode(node.left);
					dstLeft = HitAABB(ray, leftNode.AA, leftNode.BB);
				}

				if (node.right > 0.0f)
				{
					BVHNode rightNode = GetBVHNode(node.right);
					dstRight = HitAABB(ray, rightNode.AA, rightNode.BB);
				}

				// Search in recent boxes
				if (dstLeft > 0.0f && dstRight > 0.0f)
				{
					if (dstLeft < dstRight)
					{
						// Left first
						stack[stackPointer++] = node.right;
						stack[stackPointer++] = node.left;
					}
					else
					{
						// Right first
						stack[stackPointer++] = node.left;
						stack[stackPointer++] = node.right;
					}
				}
				else if (dstLeft > 0.0f)
				{
					stack[stackPointer++] = node.left;
				}
				else if (dstRight > 0.0f)
				{
					stack[stackPointer++] = node.right;
				}
			}
			else
			{
				hitCounter = 0xFFFFFFFF;
				break;
			}
		}
	}

	if (hitCounter == 0xFFFFFFFF)
	{
		return vec3(1.0f, 0.0f, 1.0f); // error: stack overflow (purple)
	}

	// Heat map
	const vec3 mapTex[] = {
		vec3(0.0f, 0.0f, 0.0f),
		vec3(0.0f, 0.0f, 1.0f),
		vec3(0.0f, 1.0f, 1.0f),
		vec3(0.0f, 1.0f, 0.0f),
		vec3(1.0f, 1.0f, 0.0f),
		vec3(1.0f, 0.0f, 0.0f),
	};

	const float mapTexLen = 5.0f;
	const float maxHeat = 100.0f;
	float l = clamp(float(hitCounter) / maxHeat, 0.0f, 1.0f) * mapTexLen;
	vec3 a = mapTex[uint(floor(l))];
	vec3 b = mapTex[uint(ceil(l))];
	vec3 heatmap = mix(a, b, l - floor(l));

	return heatmap;
}

// --------------------------------------------------------

// PCG (permuted congruential generator). Thanks to:
// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint NextRandom(inout uint state)
{
	state = state * 747796405 + 2891336453;
	uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
	result = (result >> 22) ^ result;
	return result;
}

float RandomValue(inout uint state)
{
	return NextRandom(state) / 4294967295.0f; // 2^32 - 1
}

vec2 RandomValueVec2(inout uint state)
{
	float R1 = RandomValue(state);
	float R2 = RandomValue(state);
	return vec2(R1, R2);
}

vec3 RandomValueVec3(inout uint state)
{
	float R1 = RandomValue(state);
	float R2 = RandomValue(state);
	float R3 = RandomValue(state);
	return vec3(R1, R2, R3);
}

// --------------------------------------------------------

float sqr(float x)
{
	return x * x; 
}

float SchlickFresnel(float u)
{
    float m = clamp(1.0f - u, 0.0f, 1.0f);
    float m2 = m * m;
    return m2 * m2 * m; // pow(m,5)
}

float GTR1(float NdotH, float a)
{
	if (a >= 1.0f) return 1.0f / PI;
    float a2 = a * a;
    float t = 1.0f + (a2 - 1.0f) * NdotH * NdotH;
    return (a2 - 1.0f) / (PI * log(a2) * t);
}

float GTR2(float NdotH, float a)
{
    float a2 = a * a;
    float t = 1.0f + (a2 - 1.0f) * NdotH * NdotH;
    return a2 / (PI * t * t);
}

float GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay)
{
    return 1.0f / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));
}

float smithG_GGX(float NdotV, float alphaG)
{
    float a = alphaG * alphaG;
    float b = NdotV * NdotV;
    return 1.0f / (NdotV + sqrt(a + b - a * b));
}

float smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay)
{
    return 1.0f / (NdotV + sqrt(sqr(VdotX * ax) + sqr(VdotY * ay) + sqr(NdotV)));
}

vec3 EvaluationBRDF(vec3 V, vec3 N, vec3 L, vec3 X, vec3 Y, Material material)
{
    float NdotL = dot(N, L);
    float NdotV = dot(N, V);
    if(NdotL < 0.0f || NdotV < 0.0f) return vec3(0.0f);

    vec3 H = normalize(L + V);
    float NdotH = dot(N, H);
    float LdotH = dot(L, H);

    // Initialize various colors
    vec3 Cdlin = material.baseColor;  
    vec3 Cspec = material.specular * material.specularColor;
    vec3 Cspec0 = mix(0.08f * Cspec, Cdlin, material.metallic); // 0° Specular Color
    vec3 Csheen = material.sheenColor; // Sheen Color

    // Diffuse Reflection
    float Fd90 = 0.5f + 2.0f * LdotH * LdotH * material.roughness;
    float FL = SchlickFresnel(NdotL);
    float FV = SchlickFresnel(NdotV);
    float Fd = mix(1.0f, Fd90, FL) * mix(1.0f, Fd90, FV);

    // Subsurface Scattering
    float Fss90 = LdotH * LdotH * material.roughness;
    float Fss = mix(1.0f, Fss90, FL) * mix(1.0f, Fss90, FV);
    float ss = 1.25f * (Fss * (1.0f / (NdotL + NdotV) - 0.5f) + 0.5f);
    
    // Specular Reflection - Isotropic
	float alpha = material.roughness * material.roughness;
	float Ds = GTR2(NdotH, alpha);
	float FH = SchlickFresnel(LdotH);
	vec3 Fs = mix(Cspec0, vec3(1.0f), FH);
	float Gs = smithG_GGX(NdotL, material.roughness);
	Gs *= smithG_GGX(NdotV, material.roughness);
    
    // Specular Reflection - Anisotropy
//    float aspect = sqrt(1.0f - material.anisotropy * 0.9f);
//    float ax = max(0.001f, sqr(material.roughness) / aspect);
//    float ay = max(0.001f, sqr(material.roughness) * aspect);
//    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);
//    float FH = SchlickFresnel(LdotH);
//    vec3 Fs = mix(Cspec0, vec3(1.0f), FH);
//    float Gs;
//    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);
//    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);

    // Clearcoat
    float Dr = GTR1(NdotH, mix(0.1f, 0.001f, material.clearcoatRoughness));
    float Fr = mix(0.04f, 1.0f, FH);
    float Gr = smithG_GGX(NdotL, 0.25f) * smithG_GGX(NdotV, 0.25f);

    // Sheen
    vec3 Fsheen = FH * Csheen;
    
    vec3 diffuse = (1.0f / PI) * mix(Fd, ss, material.subsurface) * Cdlin + Fsheen;
    vec3 specular = Gs * Fs * Ds;
    vec3 clearcoat = vec3(0.25f * Gr * Fr * Dr * material.clearcoat);

    return diffuse * (1.0f - material.metallic) + specular + clearcoat;
}

// --------------------------------------------------------

void GetTangentBitangent(vec3 N, inout vec3 tangent, inout vec3 bitangent)
{
    // Choose a helper vector for the cross product
	vec3 helper = abs(N.x) > 0.999f ? vec3(0.0f, 0.0f, 1.0f) : vec3(1.0f, 0.0f, 0.0f);

	// Generate vectors
	tangent = normalize(cross(N, helper));
	bitangent = normalize(cross(N, tangent));
}

mat3 GetTangentSpace(vec3 N)
{
	// Generate vectors
	vec3 T;
	vec3 B;
	GetTangentBitangent(N, T, B);

	// TBN matrix
	return mat3(T, B, N);
}

// Point on hemisphere with uniform distribution
//	u, v : in range [0, 1]
vec3 HemispherepointUniform(float u, float v)
{
	float phi = v * 2.0f * PI;
	float cosTheta = 1.0f - u;
	float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
	return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

// Point on hemisphere with cosine-weighted distribution
//	u, v : in range [0, 1]
vec3 HemispherepointCos(float u, float v)
{
	float phi = v * 2.0f * PI;
	float cosTheta = sqrt(1.0f - u);
	float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
	return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

// Get random hemisphere sample in world-space along the normal (uniform distribution)
vec3 SampleHemisphereUniform(float u, float v, vec3 N)
{
	mat3 TBN = GetTangentSpace(N);
	return TBN * HemispherepointUniform(u, v);
}

// Get random hemisphere sample in world-space along the normal (cosine-weighted distribution)
vec3 SampleHemisphereCos(float u, float v, vec3 N)
{
	mat3 TBN = GetTangentSpace(N);
	return TBN * HemispherepointCos(u, v);
}

// GTR1 importance sampling
vec3 SampleGTR1(vec2 Xi, vec3 V, vec3 N, float alpha)
{
	float phiH = 2.0f * PI * Xi.x;
	float sinPhiH = sin(phiH);
	float cosPhiH = cos(phiH);
	
	float cosThetaH = sqrt((1.0f - pow(alpha * alpha, 1.0f - Xi.y)) / (1.0f - alpha * alpha));
	float sinThetaH = sqrt(max(0.0f, 1.0f - cosThetaH * cosThetaH));

	// Sample the normal vector of the 'microfacet' as the half-angle vector h for specular reflection
    vec3 H = vec3(sinThetaH * cosPhiH, sinThetaH * sinPhiH, cosThetaH);

	// Project to normal hemisphere
	mat3 TBN = GetTangentSpace(N);
    H = TBN * H;

    // Calculate the reflection direction based on "micro-normal"
    vec3 L = reflect(-V, H);

    return L;
}

// GTR2 importance sampling
vec3 SampleGTR2(vec2 Xi, vec3 V, vec3 N, float alpha)
{
	float phiH = 2.0f * PI * Xi.x;
	float sinPhiH = sin(phiH);
	float cosPhiH = cos(phiH);
	
	float cosThetaH = sqrt((1.0f - Xi.y) / (1.0f + (alpha * alpha - 1.0f) * Xi.y));
	float sinThetaH = sqrt(max(0.0f, 1.0f - cosThetaH * cosThetaH));
	
	// Sample the normal vector of the 'microfacet' as the half-angle vector h for specular reflection
	vec3 H = vec3(sinThetaH * cosPhiH, sinThetaH * sinPhiH, cosThetaH);
	
	// Project to normal hemisphere
	mat3 TBN = GetTangentSpace(N);
	H = TBN * H;
	
    // Calculate the reflection direction based on "micro-normal"
	vec3 L = reflect(-V, H);
	
    return L;
}

// Sample three BRDFs separately according to radiance distribution
vec3 SampleBRDF(vec3 Xi, vec3 V, vec3 N, Material material)
{
	float alphaGTR1 = mix(0.1f, 0.001f, material.clearcoatRoughness);
	float alphaGTR2 = max(0.001f, sqr(material.roughness));
	
	// Radiance Statistics
    float rDiffuse = (1.0f - material.metallic);
    float rSpecular = 1.0f;
    float rClearcoat = 0.25f * material.clearcoat;
    float rSum = rDiffuse + rSpecular + rClearcoat;

    // Calculate probability based on radiance
	float pDiffuse = rDiffuse / rSum;
	float pSpecular = rSpecular / rSum;
	float pClearcoat = rClearcoat / rSum;

	// Sampling according to probability
	float rd = Xi.z;

	// Diffuse reflection
	if(rd <= pDiffuse)
	{
		return SampleHemisphereCos(Xi.x, Xi.y, N);
	}
	
	// Specular reflection
	else if(pDiffuse < rd && rd <= pDiffuse + pSpecular)
	{
		return SampleGTR2(Xi.xy, V, N, alphaGTR2);
	}

    // Clearcoat
    else if(pDiffuse + pSpecular < rd)
	{
        return SampleGTR1(Xi.xy, V, N, alphaGTR1);
    }

    return vec3(0.0f, 1.0f, 0.0f);
}

// Sample from the precomputed HDRI cache
vec3 SampleHDRI(vec2 Xi)
{
	vec2 uv = texture(sampler2D(environment.HDRICache), Xi).rg; // x, y
	uv.y = 1.0f - uv.y; // Flip

	// Get angle
	float phi = 2.0f * PI * (uv.x - 0.5f);	// [-pi ~ pi]
	float theta = PI * (uv.y - 0.5f);		// [-pi/2 ~ pi/2]

	// Calculate the direction in spherical coordinates
	vec3 L = vec3(cos(theta) * cos(phi), sin(theta), cos(theta) * sin(phi));

	return L;
}

// --------------------------------------------------------

vec2 GetSphericalCoord(vec3 V)
{
    vec2 uv = vec2(atan(V.z, V.x), asin(V.y));
    uv /= vec2(2.0 * PI, PI);
    uv += 0.5;
    uv.y = 1.0 - uv.y;
    return uv;
}

// Get HDRI environment color
vec3 EvaluationHDRI(vec3 L)
{
	vec2 uv = GetSphericalCoord(normalize(L));
	return texture(sampler2D(environment.HDRI), uv).rgb;
}

// Get the probability density of the HDRI at the position given the incoming light direction l
float ProbabilityDensityHDRI(vec3 L)
{
	vec2 uv = GetSphericalCoord(normalize(L));
	float pdf = texture(sampler2D(environment.HDRICache), uv).b; // Sample probability density
	
	float theta = PI * (1.0f - uv.y); // 1.0f for full range...
	float sinTheta = max(sin(theta), 1e-10f);

	// Conversion factor between spherical coordinates and image integration domain
	float pConvert = environment.HDRIDimensions.x * environment.HDRIDimensions.y / (2.0f * PI * PI * sinTheta);

	return pdf * pConvert;
}

float ProbabilityDensityBRDF(vec3 V, vec3 N, vec3 L, Material material) 
{
    float NdotL = dot(N, L);
    float NdotV = dot(N, V);
    if(NdotL < 0.0f || NdotV < 0.0f) return 0.0f;

    vec3 H = normalize(L + V);
    float NdotH = dot(N, H);
    float LdotH = dot(L, H);
     
    // Specular reflection - isotropic
    float alpha = max(0.001f, sqr(material.roughness));
    float Ds = GTR2(NdotH, alpha); 
    float Dr = GTR1(NdotH, mix(0.1f, 0.001f, material.clearcoatRoughness));

    // Calculate the probability density for each of the three types of BRDF separately
    float pdfDiffuse = NdotL / PI;
    float pdfSpecular = Ds * NdotH / (4.0f * dot(L, H));
    float pdfClearcoat = Dr * NdotH / (4.0f * dot(L, H));

    // Radiance statistics
    float rDiffuse = (1.0 - material.metallic);
    float rSpecular = 1.0;
    float rClearcoat = 0.25 * material.clearcoat;
    float rSum = rDiffuse + rSpecular + rClearcoat;

    // Calculate the probability of selecting a sampling method based on radiance
    float pDiffuse = rDiffuse / rSum;
    float pSpecular = rSpecular / rSum;
    float pClearcoat = rClearcoat / rSum;

    // Mix PDFs based on probabilities
    float pdf = pDiffuse   * pdfDiffuse 
              + pSpecular  * pdfSpecular
              + pClearcoat * pdfClearcoat;

    pdf = max(1e-10f, pdf);
    return pdf;
}

float misMixWeight(float a, float b)
{
	float t = a * a;
	return t / (b * b + t);
}

// --------------------------------------------------------

vec3 PathTrace(HitInfo primaryHit, Ray ray, inout uint rngState)
{
	HitInfo hitInfo = primaryHit;

	vec3 radiance	= vec3(0.0f); // Energy
	vec3 throughput	= vec3(1.0f); // Recursively accumulated color

	const uint MaxBounceCount = 3;
	for (uint bounce = 0; bounce <= MaxBounceCount; bounce++)
	{
		vec3 V = -hitInfo.hitDirection;
		vec3 N = hitInfo.normal;
		
		Ray hdriRay;
		hdriRay.origin = hitInfo.hitPoint;

		vec2 lightXi = RandomValueVec2(rngState);
		hdriRay.direction = SampleHDRI(lightXi);

		// Perform intersection test to check for occlusion
		if (dot(N, hdriRay.direction) > 0.0f)
		{
			// Skip test if sampling direction is away from point p
			HitInfo hdriHitInfo = HitBVH(hdriRay);

			// Sky light accumulates brightness only when there are no occlusion
			if (!hdriHitInfo.didHit)
			{
				// Get the following to acquire sampling direction L: 1 Light contribution, 2. The PDF of the 
				// environment map at that location, 3. BRDF function value, 4. The PDF of the BRDF in that direction

				// Light
				vec3 L = hdriRay.direction;
				vec3 colorLight = EvaluationHDRI(L);
				float pdfLight = ProbabilityDensityHDRI(L);

				// BRDF
				vec3 tangent;
				vec3 bitangent;
				GetTangentBitangent(N, tangent, bitangent);
				vec3 f = EvaluationBRDF(V, N, L, bitangent, tangent, hitInfo.material);
				float pdfBRDF = ProbabilityDensityBRDF(V, N, L, hitInfo.material);

				if (pdfBRDF > 0.0f)
				{
					// Multiple importance sampling
					float misWeight = misMixWeight(pdfLight, pdfBRDF);
					if (misWeight > 0.0f)
					{
						radiance += misWeight * throughput * colorLight * f * dot(N, L) / pdfLight;
					}
				}
			}
		}

		// Sample BRDF to get a direction L
		vec3 brdfXi = RandomValueVec3(rngState);
		vec3 L = SampleBRDF(brdfXi, V, N, hitInfo.material);
		
		float NdotL = dot(N, L);
		if (NdotL <= 0.0f) break;
		
		// Get tangent and bitangent
		vec3 tangent;
		vec3 bitangent;
		GetTangentBitangent(N, tangent, bitangent);

		// Obtain the BRDF value and probability density for the direction L
		vec3 f = EvaluationBRDF(V, N, L, bitangent, tangent, hitInfo.material);
		float pdfBRDF = ProbabilityDensityBRDF(V, N, L, hitInfo.material);
		if (pdfBRDF <= 0.0f) break;

		// Initialize ray of light
		ray.origin = hitInfo.hitPoint;
		ray.direction = L;
		hitInfo = HitBVH(ray);

		// Missed - HDRI light contribution
		if (!hitInfo.didHit)
		{
			vec3 colorLight = EvaluationHDRI(L);
			float pdfLight = ProbabilityDensityHDRI(L);

			// Multiple importance sampling
			float misWeight = misMixWeight(pdfBRDF, pdfLight);
			if (misWeight > 0.0f)
			{
				// Indirect lighting rays are emitted according to BRDF distribution
				radiance += misWeight * throughput * colorLight * f * NdotL / pdfBRDF;
			}

			break;
		}

		// Emissive contribution
		vec3 emission = hitInfo.material.emissiveColor;
		radiance += throughput * emission * f * NdotL / pdfBRDF;

		// Accumulate result
		throughput *= f * NdotL / pdfBRDF;

		// Russian roulette
		// Random early exit if ray colour is nearly 0 (can't contribute much to final result)
		float p = max(throughput.r, max(throughput.g, throughput.b));
		if (RandomValue(rngState) >= p) 
		{
			break;
		}
		throughput *= 1.0f / p;
	}

	return radiance;
}

// --------------------------------------------------------

// Generate primary ray using pinhole camera
Ray GeneratePinholeCameraRay(vec2 uv)
{
	// Start from transformed position
	vec4 viewPos = InvProjMatrix * vec4(uv * 2.0f - 1.0f, 0.0f, 1.0f);
	vec3 origin = viewPos.xyz / viewPos.w;
	vec3 direction = normalize(origin); // Normalize to get view direction

	// Compute origin and direction based on view matrix
	Ray ray;
	ray.origin = (inverse(ViewMatrix) * vec4(origin, 1)).xyz;
	ray.direction = (inverse(ViewMatrix) * vec4(direction, 0)).xyz;

	return ray;
}

// Generate primary ray using thin lens model
Ray GenerateThinLensCameraRay(vec2 uv, inout uint rngState)
{
	// Extract camera vectors from view matrix
	vec3 cameraForward = -vec3(ViewMatrix[2][0], ViewMatrix[2][1], ViewMatrix[2][2]);
	vec3 cameraUp = vec3(ViewMatrix[1][0], ViewMatrix[1][1], ViewMatrix[1][2]);
	vec3 cameraRight = cross(cameraUp, cameraForward);

	// Find first point in distance at which we want perfect focus
	Ray ray = GeneratePinholeCameraRay(uv);
	vec3 focalPoint = ray.origin + ray.direction * FocalLength;

	// Sample aperture shape
	vec2 apertureSample = HemispherepointCos(RandomValue(rngState), RandomValue(rngState)).xy * ApertureShape * ApertureSize;

	// Jitter the ray origin within camera plane using aperture sample	
	ray.origin = ray.origin + cameraRight * apertureSample.x + cameraUp * apertureSample.y;

	// Set ray direction from jittered origin towards the focal point
	ray.direction = normalize(focalPoint - ray.origin);

	return ray;
}

// Generates primary ray using either pinhole or thin lens model
Ray GeneratePrimaryRay(vec2 uv, inout uint rngState)
{
	if (ApertureSize == 0.0f)
	{
		return GeneratePinholeCameraRay(uv);
	}
	else
	{
		return GenerateThinLensCameraRay(uv, rngState);
	}
}

// --------------------------------------------------------

// Debug HDRI Cache: Draw red dots on important sources of light
vec4 DebugHDRICache(vec2 uv)
{
	vec3 hdriColor = texture(sampler2D(environment.HDRI), vec2(uv.x, -uv.y)).rgb;

    // Sample points
    for(uint i = 0u; i < 500u; i++)
	{
		uint XiState = i;
		vec2 Xi = RandomValueVec2(XiState);

        vec2 texcoord = texture(sampler2D(environment.HDRICache), Xi).rg;
        texcoord.y = 1.0f - texcoord.y;

		// Mark areas red that follow HDRI cache
        if(distance(uv, texcoord) < 0.005f)
		{
			hdriColor = vec3(1.0f, 0.0f, 0.0f);
		}
    }

	return vec4(hdriColor, 1.0f);
}

// Debug BVH: Count BVH node intersections on a given ray
vec4 DebugBVH(Ray debugRay)
{
	vec3 bvhColor = HitBVHDebug(debugRay);
	return vec4(bvhColor, 1.0f);
}

// Choose debug output function
vec4 DebugOutput(vec2 uv, Ray debugRay)
{
#if defined(DEBUG_HDRI_CACHE)
	return DebugHDRICache(uv);
#elif defined(DEBUG_BVH)
	return DebugBVH(debugRay);
#endif
	return vec4(0.0f);
}

// --------------------------------------------------------

void main()
{
	// Initialize pixel coordinate information
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (texelCoord + 0.5f) / FrameDimensions;

	// Initialize rng state
	uint pixelIndex = texelCoord.y * uint(FrameDimensions.x) + texelCoord.x;
	uint rngState = pixelIndex + FrameCount * 719393;

	// Debug: Output meaningful data for analysis
#if defined(DEBUG_ENABLED)
	Ray debugRay = GeneratePinholeCameraRay(uv);
	vec4 debugValue = DebugOutput(uv, debugRay);

	imageStore(imgOutput, texelCoord, debugValue);
	return;
#endif

	// Initialize primary ray
	Ray ray = GeneratePrimaryRay(uv, rngState);

	// Generate primary hit information
	HitInfo primaryHit = HitBVH(ray);

	vec3 result = vec3(0.0f);
	vec3 primaryBaseColor = vec3(0.0f);
	vec3 primaryNormal = vec3(0.0f);

	// No reason to trace if we hit background the first time
	if (!primaryHit.didHit)
	{
		// Sample HDRI
		vec3 L = ray.direction;
		result = EvaluationHDRI(L);
	}
	else
	{
		// PathTrace 
		result = PathTrace(primaryHit, ray, rngState);

		// Fetch denoiser essentials
		primaryBaseColor = primaryHit.material.baseColor;
		primaryNormal = primaryHit.normal;
	}

	// Current state
	vec3 currentColor = result;
	vec3 previousColor = texelFetch(PreviousAccumulationTexture, texelCoord, 0).rgb;
	
	// Temporal accumulation. Weigh the contributions to result in an average over all frames.
	float weight = 1.0f / FrameCount;
	vec3 accumulatedColor = previousColor * (1.0f - weight) + currentColor * weight;
	
	// Value
	vec4 primaryBaseColorValue = vec4(primaryBaseColor, 1.0f);
	vec4 primaryNormalValue = vec4(primaryNormal, 1.0f);
	vec4 accumulationValue = vec4(accumulatedColor, 1.0f);

	// Output
	imageStore(primaryBaseColorOutput, texelCoord, primaryBaseColorValue);
	imageStore(primaryNormalOutput, texelCoord, primaryNormalValue);
	imageStore(accumulationOutput, texelCoord, accumulationValue);
}
