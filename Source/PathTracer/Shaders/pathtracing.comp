
#version 460

#extension GL_ARB_bindless_texture : require
#extension GL_ARB_gpu_shader_int64 : enable

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D radianceImage;
layout(rgba32f, binding = 1) uniform image2D primaryAlbedoImage;
layout(rgba32f, binding = 2) uniform image2D primaryNormalImage;

// --------------------------------------------------------

uniform mat4 ViewMatrix;
uniform mat4 ProjMatrix;
uniform mat4 InvProjMatrix;
uniform uint FrameCount;
uniform vec2 FrameDimensions;
uniform uint AntiAliasingEnabled;
uniform float FocalLength;
uniform float ApertureSize;
uniform vec2 ApertureShape;
uniform float DebugValueA;
uniform float DebugValueB;

// --------------------------------------------------------

const float PI			= 3.141592653589f;
const float TWO_PI		= 6.283185307178f;
const float ONE_OVER_PI = 0.318309886183f;

const float FLT_MAX = 3.402823466e+38f;

#define BVH_STACKSIZE 16

// --------------------------------------------------------

//#define DEBUG_HDRI_CACHE
//#define DEBUG_BVH

#if defined(DEBUG_HDRI_CACHE) || defined(DEBUG_BVH)
#define DEBUG_ENABLED
#endif

// --------------------------------------------------------

struct Settings
{
	float debugValueA;
	float debugValueB;
};

struct Environment
{
	uint64_t hdriHandle;
	uint64_t hdriCacheHandle;
	vec2 hdriDimensions;
};

struct Material
{
    uint64_t emissionTextureHandle;
    uint64_t albedoTextureHandle;
    uint64_t normalTextureHandle;
    uint64_t specularTextureHandle;
    uint64_t specularColorTextureHandle;
    uint64_t metallicRoughnessTextureHandle;
    uint64_t sheenRoughnessTextureHandle;
    uint64_t sheenColorTextureHandle;
    uint64_t clearcoatTextureHandle;
    uint64_t clearcoatRoughnessTextureHandle;
    uint64_t transmissionTextureHandle;

    vec3 emission;
    vec3 albedo;
    float specular;
    float specularTint;
    float metallic;
    float roughness;
    float subsurface;
    float anisotropy;
    float sheenRoughness;
    float sheenTint;
    float clearcoat;
    float clearcoatRoughness;
    float refraction;
    float transmission;
};

struct BvhNode
{
	int left;   // Left subtree
    int right;  // Right subtree
    int n;      // Number of primitives
    int index;	// Primitive index
    vec3 AA;	// Bounding box AA
	vec3 BB;	// Bounding box BB
};

struct BvhPrimitive
{
	vec4 posAuvX;
	vec4 norAuvY;

	vec4 posBuvX;
	vec4 norBuvY;

	vec4 posCuvX;
	vec4 norCuvY;

	uint meshIndex;
};

// --------------------------------------------------------

layout(std430, binding = 0) readonly buffer SettingsBuffer
{
    Settings settings;
};

layout(std430, binding = 1) readonly buffer EnvironmentBuffer
{
    Environment environment;
};

layout(std430, binding = 2) readonly buffer MaterialBuffer
{
    Material materials[];
};

layout(std430, binding = 3) readonly buffer BvhNodeBuffer
{
    BvhNode BvhNodes[];
};

layout(std430, binding = 4) readonly buffer BvhPrimitiveBuffer
{
    BvhPrimitive BvhPrimitives[];
};

// --------------------------------------------------------

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct HitInfo
{
	bool didHit;
	vec3 hitPosition;
	vec3 hitDirection;
	float dst;
	vec2 uv;
	vec3 shadingNormal;
	vec3 geometryNormal;
	vec3 tangent;
	vec3 bitangent;
	Material material;
};

struct BrdfData
{
	// Roughnesses
	float roughness;				// perceptively linear roughness (artist's input)
	float alpha;					// linear roughness - often 'alpha' in specular BRDF equations
	float alphaSquared;				// alpha squared - pre-calculated value commonly used in BRDF equations
	float alphaAnisotropicX;		// Anisotropic specific roughness value based on tangent
	float alphaAnisotropicY;		// Anisotropic specific roughness value based on bitangent
	float roughnessClearcoat;
	float alphaClearcoat;
	float alphaSquaredClearcoat;

	// Vectors
	vec3 V; // Direction to viewer (or opposite direction of indident ray)
	vec3 N; // Shading normal
	vec3 L; // Direction to light (or direction of reflecting ray)
	vec3 H; // Half vector (microfacet normal)
	vec3 X;	// Tangent
	vec3 Y; // Bitangent

	// Angles
	float NdotV;
	float NdotL;
	float VdotH;
	float NdotH;
	float LdotH;
	float VdotX;
	float LdotX;
	float HdotX;
	float VdotY;
	float LdotY;
	float HdotY;

	// Common used terms for BRDF evaluation
	float incidentIor;
	float F0;
};

// --------------------------------------------------------

// Note: Triangle order matters! Must go counter-clock wise
// Calculate the intersection of a ray with a triangle using Möller–Trumbore algorithm
// Based on: https://stackoverflow.com/a/42752998
HitInfo RayTriangle(Ray ray, BvhPrimitive primitive)
{
	vec3 posA = primitive.posAuvX.xyz;
	vec3 posB = primitive.posBuvX.xyz;
	vec3 posC = primitive.posCuvX.xyz;

	vec3 norA = primitive.norAuvY.xyz;
	vec3 norB = primitive.norBuvY.xyz;
	vec3 norC = primitive.norCuvY.xyz;
	
	vec2 uvA = vec2(primitive.posAuvX.w, primitive.norAuvY.w);
	vec2 uvB = vec2(primitive.posBuvX.w, primitive.norBuvY.w);
	vec2 uvC = vec2(primitive.posCuvX.w, primitive.norCuvY.w);

	vec3 edgeAB = posB - posA;
	vec3 edgeAC = posC - posA;
	vec3 normalVector = cross(edgeAB, edgeAC);
	vec3 ao = ray.origin - posA;
	vec3 dao = cross(ao, ray.direction);

	float determinant = -dot(ray.direction, normalVector);
	float invDet = 1.0f / determinant;
	
	// Calculate dst to triangle & barycentric coordinates of intersection point
	float dst = dot(ao, normalVector) * invDet;
	float u = dot(edgeAC, dao) * invDet;
	float v = -dot(edgeAB, dao) * invDet;
	float w = 1.0f - u - v;
	
	// Initialize hit info
	HitInfo hitInfo;
	hitInfo.didHit = determinant >= 1e-10 && dst >= 0.0f && u >= 0.0f && v >= 0.0f && w >= 0.0f;
	hitInfo.hitPosition = ray.origin + ray.direction * dst;
	hitInfo.hitDirection = ray.direction;
	hitInfo.dst = dst;

	// Calculate shading normal, geometry normal, and uv
	hitInfo.uv = uvA * w + uvB * u + uvC * v;
	hitInfo.shadingNormal = normalize(norA * w + norB * u + norC * v);
	hitInfo.geometryNormal = normalize(cross(edgeAC, edgeAB));

	// Calculate tangent and bitangent
	vec2 deltaUVB = uvB - uvA;
    vec2 deltaUVC = uvC - uvA;

    float invTangentDeterminant = 1.0f / (deltaUVB.x * deltaUVC.y - deltaUVB.y * deltaUVC.x);

    hitInfo.tangent = (edgeAB * deltaUVC.y - edgeAC * deltaUVB.y) * invTangentDeterminant;
    hitInfo.bitangent = (edgeAC * deltaUVB.x - edgeAB * deltaUVC.x) * invTangentDeterminant;

	return hitInfo;
}

// Return distance between ray and AABB box
float HitAABB(Ray r, vec3 AA, vec3 BB) 
{
    vec3 invdir = 1.0 / r.direction;

    vec3 f = (BB - r.origin) * invdir;
    vec3 n = (AA - r.origin) * invdir;

    vec3 tmax = max(f, n);
    vec3 tmin = min(f, n);

    float t1 = min(tmax.x, min(tmax.y, tmax.z));
    float t0 = max(tmin.x, max(tmin.y, tmin.z));

    return (t1 >= t0) ? ((t0 > 0.0) ? (t0) : (t1)) : (-1);
}

// --------------------------------------------------------

vec3 SampleNormalMap(sampler2D normalTexture, HitInfo hitInfo)
{
	vec3 N = hitInfo.shadingNormal;
	vec3 T = hitInfo.tangent;

	// Gram-Schmidt process: Re-orthogonalize T with respect to N
	T = normalize(T - dot(T, N) * N);

	// Recalculate bitangent due to Gram-Schmidt
	vec3 B = cross(N, T);

	// Create tangent space matrix
	// mat3 TBN = transpose(mat3(T, B, N)); // ???
	mat3 TBN = mat3(T, B, N);

	// Sample normal texture
	vec3 normalMap = texture(normalTexture, hitInfo.uv).rgb;

	// Transform normal vector to range [-1,1]
    normalMap = normalize(normalMap * 2.0 - 1.0);

	// Apply tangent space matrix
    normalMap = normalize(TBN * normalMap);

    return normalize(normalMap);
}

Material EvaluateMaterial(Material material, inout HitInfo hitInfo)
{
	Material evalutedMaterial = material;

	if (material.emissionTextureHandle != 0)
	{
		vec3 emissionSample = texture(sampler2D(material.emissionTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.emission *= emissionSample;
	}

	if (material.albedoTextureHandle != 0)
	{
		vec3 albedoSample = texture(sampler2D(material.albedoTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.albedo *= albedoSample;
	}

	if (material.normalTextureHandle != 0)
	{
		hitInfo.shadingNormal = SampleNormalMap(sampler2D(material.normalTextureHandle), hitInfo);
	}

	if (material.specularTextureHandle != 0)
	{
		float specularSample = texture(sampler2D(material.specularTextureHandle), hitInfo.uv).a;
		evalutedMaterial.specular *= specularSample;
	}

	if (material.specularColorTextureHandle != 0)
	{
		vec3 specularColorSample = texture(sampler2D(material.specularColorTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.specularTint *= length(specularColorSample); // We only care about magnitude, color will be sampled according to Disney
	}

	if (material.metallicRoughnessTextureHandle != 0)
	{
		vec2 metallicRoughnessSample = texture(sampler2D(material.metallicRoughnessTextureHandle), hitInfo.uv).rg;
		evalutedMaterial.metallic *= metallicRoughnessSample.x;
		evalutedMaterial.roughness *= metallicRoughnessSample.y;
	}

	if (material.sheenRoughnessTextureHandle != 0)
	{
		float sheenRoughnessSample = texture(sampler2D(material.sheenRoughnessTextureHandle), hitInfo.uv).a;
		evalutedMaterial.sheenRoughness *= sheenRoughnessSample;
	}

	if (material.sheenColorTextureHandle != 0)
	{
		vec3 sheenColorSample = texture(sampler2D(material.sheenColorTextureHandle), hitInfo.uv).rgb;
		evalutedMaterial.sheenTint *= length(sheenColorSample); // We only care about magnitude, color will be sampled according to Disney
	}

	if (material.clearcoatTextureHandle != 0)
	{
		float clearcoatSample = texture(sampler2D(material.clearcoatTextureHandle), hitInfo.uv).r;
		evalutedMaterial.clearcoat *= clearcoatSample;
	}

	if (material.clearcoatRoughnessTextureHandle != 0)
	{
		float clearcoatRoughnessSample = texture(sampler2D(material.clearcoatRoughnessTextureHandle), hitInfo.uv).g;
		evalutedMaterial.clearcoatRoughness *= clearcoatRoughnessSample;
	}

	if (material.transmissionTextureHandle != 0)
	{
		float transmissionSample = texture(sampler2D(material.transmissionTextureHandle), hitInfo.uv).r;
		evalutedMaterial.transmission *= transmissionSample;
	}

	return evalutedMaterial;
}

// --------------------------------------------------------

BvhPrimitive GetBvhPrimitive(int index)
{
	BvhPrimitive primitive = BvhPrimitives[index];
	return primitive;
}

Material GetMaterial(unsigned int index)
{
	Material material = materials[index];
	return material;
}

HitInfo HitArray(Ray ray, int L, int R)
{
	HitInfo closestHit;
	closestHit.didHit = false;
	closestHit.dst = FLT_MAX;

	for (int i = L; i <= R; i++)
	{
		BvhPrimitive primitive = GetBvhPrimitive(i);
		HitInfo hitInfo = RayTriangle(ray, primitive);

		if (hitInfo.didHit && hitInfo.dst < closestHit.dst)
		{
			closestHit = hitInfo;
			
			Material currentMaterial = GetMaterial(primitive.meshIndex);
			Material evaluatedMaterial = EvaluateMaterial(currentMaterial, hitInfo);

			closestHit.material = evaluatedMaterial;
		}
	}

	return closestHit;
}

BvhNode GetBvhNode(int index)
{
	BvhNode node = BvhNodes[index];
	return node;
}

HitInfo HitBvh(Ray ray)
{
	HitInfo closestHit;
	closestHit.didHit = false;
	closestHit.dst = FLT_MAX;

	// Stack
	int stack[BVH_STACKSIZE];
	int stackPointer = 0;

	stack[stackPointer++] = 1;
	while(stackPointer > 0)
	{
		int top = stack[--stackPointer];
		BvhNode node = GetBvhNode(top);

		// If node is leaf, traverse primitives and find intersection
		if (node.n > 0)
		{
			int L = node.index;
			int R = node.index + node.n - 1;

			// Go through all primitives inside of BVH node range
			HitInfo hitInfo = HitArray(ray, L, R);
			
			// Out of the other nodes, did this one perform better?
			if (hitInfo.didHit && hitInfo.dst < closestHit.dst)
			{
				closestHit = hitInfo;
			}
		}
		else
		{
			if (stackPointer < BVH_STACKSIZE)
			{
				// Find intersection with left and right boxes AABB
				float dstLeft = FLT_MAX;
				float dstRight = FLT_MAX;

				if (node.left > 0.0f)
				{
					BvhNode leftNode = GetBvhNode(node.left);
					dstLeft = HitAABB(ray, leftNode.AA, leftNode.BB);
				}

				if (node.right > 0.0f)
				{
					BvhNode rightNode = GetBvhNode(node.right);
					dstRight = HitAABB(ray, rightNode.AA, rightNode.BB);
				}

				// Search in recent boxes
				if (dstLeft > 0.0f && dstRight > 0.0f)
				{
					if (dstLeft < dstRight)
					{
						// Left first
						stack[stackPointer++] = node.right;
						stack[stackPointer++] = node.left;
					}
					else
					{
						// Right first
						stack[stackPointer++] = node.left;
						stack[stackPointer++] = node.right;
					}
				}
				else if (dstLeft > 0.0f)
				{
					stack[stackPointer++] = node.left;
				}
				else if (dstRight > 0.0f)
				{
					stack[stackPointer++] = node.right;
				}
			}
			else
			{
				break;
			}
		}
	}

	return closestHit;
}

vec3 HitBvhDebug(Ray ray)
{
	uint hitCounter = 0;

	// Stack
	int stack[BVH_STACKSIZE];
	int stackPointer = 0;

	stack[stackPointer++] = 1;
	while(stackPointer > 0)
	{
		int top = stack[--stackPointer];
		BvhNode node = GetBvhNode(top);

		// If node is leaf, traverse primitives and find intersection
		if (node.n > 0)
		{
			hitCounter++;
		}
		else
		{
			if (stackPointer < BVH_STACKSIZE)
			{
				// Find intersection with left and right boxes AABB
				float dstLeft = FLT_MAX;
				float dstRight = FLT_MAX;

				if (node.left > 0.0f)
				{
					BvhNode leftNode = GetBvhNode(node.left);
					dstLeft = HitAABB(ray, leftNode.AA, leftNode.BB);
				}

				if (node.right > 0.0f)
				{
					BvhNode rightNode = GetBvhNode(node.right);
					dstRight = HitAABB(ray, rightNode.AA, rightNode.BB);
				}

				// Search in recent boxes
				if (dstLeft > 0.0f && dstRight > 0.0f)
				{
					if (dstLeft < dstRight)
					{
						// Left first
						stack[stackPointer++] = node.right;
						stack[stackPointer++] = node.left;
					}
					else
					{
						// Right first
						stack[stackPointer++] = node.left;
						stack[stackPointer++] = node.right;
					}
				}
				else if (dstLeft > 0.0f)
				{
					stack[stackPointer++] = node.left;
				}
				else if (dstRight > 0.0f)
				{
					stack[stackPointer++] = node.right;
				}
			}
			else
			{
				hitCounter = 0xFFFFFFFF;
				break;
			}
		}
	}

	if (hitCounter == 0xFFFFFFFF)
	{
		return vec3(1.0f, 0.0f, 1.0f); // error: stack overflow (purple)
	}

	// Heat map
	const vec3 mapTex[] = {
		vec3(0.0f, 0.0f, 0.0f),
		vec3(0.0f, 0.0f, 1.0f),
		vec3(0.0f, 1.0f, 1.0f),
		vec3(0.0f, 1.0f, 0.0f),
		vec3(1.0f, 1.0f, 0.0f),
		vec3(1.0f, 0.0f, 0.0f),
	};

	const float mapTexLen = 5.0f;
	const float maxHeat = 100.0f;
	float l = clamp(float(hitCounter) / maxHeat, 0.0f, 1.0f) * mapTexLen;
	vec3 a = mapTex[uint(floor(l))];
	vec3 b = mapTex[uint(ceil(l))];
	vec3 heatmap = mix(a, b, l - floor(l));

	return heatmap;
}

// --------------------------------------------------------

// PCG (permuted congruential generator). Thanks to:
// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint NextRandom(inout uint state)
{
	state = state * 747796405 + 2891336453;
	uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
	result = (result >> 22) ^ result;
	return result;
}

// Random float in range [0; 1]
float RandomValue(inout uint state)
{
	return NextRandom(state) / 4294967295.0f; // 2^32 - 1
}

// Random vec2 where components are in range [0; 1]
vec2 RandomValueVec2(inout uint state)
{
	float R1 = RandomValue(state);
	float R2 = RandomValue(state);
	return vec2(R1, R2);
}

// Random vec3 where components are in range [0; 1]
vec3 RandomValueVec3(inout uint state)
{
	float R1 = RandomValue(state);
	float R2 = RandomValue(state);
	float R3 = RandomValue(state);
	return vec3(R1, R2, R3);
}

// Clever offset_ray function from Ray Tracing Gems chapter 6
// Offsets the ray origin from current position p, along normal n (which must be geometric normal)
// so that no self-intersection can occur.
vec3 OffsetRay(vec3 P, vec3 N)
{
	const float origin = 1.0f / 32.0f;
	const float floatScale = 1.0f / 65536.0f;
	const float intScale = 256.0f;

	ivec3 of_i = ivec3(intScale * N.x, intScale * N.y, intScale * N.z);

	vec3 p_i = vec3(
		intBitsToFloat(floatBitsToInt(P.x) + ((P.x < 0.0f) ? -of_i.x : of_i.x)),
		intBitsToFloat(floatBitsToInt(P.y) + ((P.y < 0.0f) ? -of_i.y : of_i.y)),
		intBitsToFloat(floatBitsToInt(P.z) + ((P.z < 0.0f) ? -of_i.z : of_i.z)));

	return vec3(
		abs(P.x) < origin ? P.x + floatScale * N.x : p_i.x,
		abs(P.y) < origin ? P.y + floatScale * N.y : p_i.y,
		abs(P.z) < origin ? P.z + floatScale * N.z : p_i.z);
}

void GetTangentBitangent(vec3 N, inout vec3 tangent, inout vec3 bitangent)
{
    // Choose a helper vector for the cross product
	vec3 helper = abs(N.x) > 0.999f ? vec3(0.0f, 0.0f, 1.0f) : vec3(1.0f, 0.0f, 0.0f);

	// Generate vectors
	tangent = normalize(cross(N, helper));
	bitangent = normalize(cross(N, tangent));
}

mat3 GetTangentSpace(vec3 N)
{
	// Generate vectors
	vec3 T;
	vec3 B;
	GetTangentBitangent(N, T, B);

	// TBN matrix
	return mat3(T, B, N);
}

vec3 ToLocal(vec3 N, vec3 V)
{
	// Since the T, B, N are orthonormal, transpose operation is equivalent to the inverse
	return transpose(GetTangentSpace(N)) * V;
}

vec3 ToWorld(vec3 N, vec3 V)
{
	return GetTangentSpace(N) * V;
}

float sqr(float x)
{
	return x * x; 
}

float Luminance(vec3 rgb)
{
	return dot(rgb, vec3(0.2126f, 0.7152f, 0.0722f));
}

float misMixWeight(float a, float b)
{
	float t = a * a;
	return t / (b * b + t);
}

// --------------------------------------------------------

// Point on hemisphere with uniform distribution
//	u, v : in range [0, 1]
vec3 HemispherepointUniform(float u, float v)
{
	float phi = v * TWO_PI;
	float cosTheta = 1.0f - u;
	float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
	return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

// Point on hemisphere with cosine-weighted distribution
//	u, v : in range [0, 1]
vec3 HemispherepointCos(float u, float v)
{
	float phi = v * TWO_PI;
	float cosTheta = sqrt(1.0f - u);
	float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
	return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

vec3 SampleGTR1(vec2 Xi, float a)
{
	float a2 = a * a;

	float phiH = TWO_PI * Xi.x;
	float sinPhiH = sin(phiH);
	float cosPhiH = cos(phiH);
	
	float cosThetaH = sqrt((1.0f - pow(a2, 1.0f - Xi.y)) / (1.0f - a2));
	float sinThetaH = sqrt(max(0.0f, 1.0f - cosThetaH * cosThetaH));

	// Sample the normal vector of the 'microfacet' as the half-angle vector h for specular reflection
    return vec3(sinThetaH * cosPhiH, sinThetaH * sinPhiH, cosThetaH);
}

// GTR2 importance sampling
vec3 SampleGTR2(vec2 Xi, float a)
{
	float a2 = a * a;

	float phiH = TWO_PI * Xi.x;
	float sinPhiH = sin(phiH);
	float cosPhiH = cos(phiH);
	
	float cosThetaH = sqrt((1.0f - Xi.y) / (1.0f + (a2 - 1.0f) * Xi.y));
	float sinThetaH = sqrt(max(0.0f, 1.0f - cosThetaH * cosThetaH));
	
	// Sample the normal vector of the 'microfacet' as the half-angle vector h for specular reflection
	return vec3(sinThetaH * cosPhiH, sinThetaH * sinPhiH, cosThetaH);
}

// Samples a microfacet normal for the GGX distribution using VNDF method.
// Source: "Sampling the GGX Distribution of Visible Normals" by Heitz
// See also https://hal.inria.fr/hal-00996995v1/document and http://jcgt.org/published/0007/04/01/
// Random variables 'u' must be in <0;1) interval
// PDF is 'G1(NdotV) * D'
vec3 SampleGGXVNDF(vec3 Ve, float ax, float ay, vec2 Xi)
{
	// Section 3.2: transforming the view direction to the hemisphere configuration
	vec3 Vh = normalize(vec3(ax * Ve.x, ay * Ve.y, Ve.z));

	// Section 4.1: orthonormal basis (with special case if cross product is zero)
	float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
	vec3 T1 = lensq > 0.0f ? vec3(-Vh.y, Vh.x, 0.0f) * inversesqrt(lensq) : vec3(1.0f, 0.0f, 0.0f);
	vec3 T2 = cross(Vh, T1);

	// Section 4.2: parameterization of the projected area
	float r = sqrt(Xi.x);
	float phi = TWO_PI * Xi.y;
	float t1 = r * cos(phi);
	float t2 = r * sin(phi);
	float s = 0.5f * (1.0f + Vh.z);
	t2 = mix(sqrt(1.0f - t1 * t1), t2, s);

	// Section 4.3: reprojection onto hemisphere
	vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0f, 1.0f - t1 * t1 - t2 * t2)) * Vh;

	// Section 3.4: transforming the normal back to the ellipsoid configuration
	return normalize(vec3(ax * Nh.x, ay * Nh.y, max(0.0f, Nh.z)));
}

// --------------------------------------------------------

float IorToF0(float transmittedIor, float incidentIor)
{
	return sqr((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

float F0ToIor(float f0)
{
	float r = sqrt(f0);
	return (1.0 + r) / (1.0 - r);
}

BrdfData PrepareEvaluationBrdfData(Material material, vec3 V, vec3 N, vec3 L)
{
	BrdfData data;

	// Get tangent and bitangent
	vec3 X;
	vec3 Y;
	GetTangentBitangent(N, X, Y);

	// Unpack 'perceptively linear' -> 'linear' -> 'squared' roughness
	data.roughness = clamp(material.roughness, 0.001f, 0.999f);
	data.alpha = data.roughness * data.roughness;
	data.alphaSquared = data.alpha * data.alpha;
	data.alphaAnisotropicX = max(0.001f, data.alpha * (1.0f + material.anisotropy));
	data.alphaAnisotropicY = max(0.001f, data.alpha * (1.0f - material.anisotropy));
	data.roughnessClearcoat = clamp(material.clearcoatRoughness, 0.001f, 0.999f);
	data.alphaClearcoat = data.roughnessClearcoat * data.roughnessClearcoat;
	data.alphaSquaredClearcoat = data.alphaClearcoat * data.alphaClearcoat;

	// Evaluate VNLHXY vectors
	data.V = V;
	data.N = N;
	data.L = L;

	// Pre-calculate for eta and H
	float NdotV = dot(data.N, data.V);
	float NdotL = dot(data.N, data.L);

	// eta to estimate in and out refractive direction, based on V backfacing
	data.incidentIor = NdotV <= 0.0f ? material.refraction : (1.0f / material.refraction);

	// Calculate half vector based on eta, based on L backfacing
	data.H = NdotL <= 0.0f ? normalize(L + V * data.incidentIor) : normalize(L + V);

	// Avoid half vector going into ground
	float NdotH = dot(N, data.H);
	if (NdotH < 0.0f)
		data.H = -data.H;

	data.X = X;
	data.Y = Y;

	data.NdotV = NdotV;
	data.NdotL = NdotL;
	data.VdotH = dot(data.V, data.H);
	data.NdotH = dot(data.N, data.H);
	data.LdotH = dot(data.L, data.H);
	data.VdotX = dot(data.V, data.X);
	data.LdotX = dot(data.L, data.X);
	data.HdotX = dot(data.H, data.X);
	data.VdotY = dot(data.V, data.Y);
	data.LdotY = dot(data.L, data.Y);
	data.HdotY = dot(data.H, data.Y);

	// Pre-calculate some more BRDF terms
	data.F0 = IorToF0(1.0f, data.incidentIor);

	return data;
}

// --------------------------------------------------------

float SchlickFresnel(float u)
{
    float m = clamp(1.0f - u, 0.0f, 1.0f);
    float m2 = m * m;
    return m2 * m2 * m; // pow(m,5)
}

float DielectricFresnel(float cosThetaI, float eta)
{
    float sinThetaTSq = eta * eta * (1.0f - cosThetaI * cosThetaI);

    // Total internal reflection
    if (sinThetaTSq > 1.0)
        return 1.0;

    float cosThetaT = sqrt(max(1.0 - sinThetaTSq, 0.0));

    float rs = (eta * cosThetaT - cosThetaI) / (eta * cosThetaT + cosThetaI);
    float rp = (eta * cosThetaI - cosThetaT) / (eta * cosThetaI + cosThetaT);

    return 0.5f * (rs * rs + rp * rp);
}

float GTR1(float NdotH, float a)
{
	if (a >= 1.0f) return ONE_OVER_PI;
    float a2 = a * a;
    float t = 1.0f + (a2 - 1.0f) * NdotH * NdotH;
    return (a2 - 1.0f) / (PI * log(a2) * t);
}

float GTR2(float NdotH, float a)
{
    float a2 = a * a;
    float t = 1.0f + (a2 - 1.0f) * NdotH * NdotH;
    return a2 / (PI * t * t);
}

float GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay)
{
    return 1.0f / (PI * ax * ay * sqr(sqr(HdotX / ax) + sqr(HdotY / ay) + NdotH * NdotH));
}

float smithG_GGX(float NdotV, float alphaG)
{
    float a = alphaG * alphaG;
    float b = NdotV * NdotV;
    return 1.0f / (NdotV + sqrt(a + b - a * b));
}

float smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay)
{
    return 1.0f / (NdotV + sqrt(sqr(VdotX * ax) + sqr(VdotY * ay) + sqr(NdotV)));
}

void TintColors(Material material, BrdfData brdfData, out vec3 Csheen, out vec3 Cspec0)
{
	vec3 Cdlin = material.albedo;
	float Cdlum = Luminance(Cdlin);
	vec3 Ctint = Cdlum > 0.0f ? Cdlin / Cdlum : vec3(1.0f);

    Cspec0 = brdfData.F0 * mix(vec3(1.0f), Ctint, material.specularTint); // 0° Specular Color
	Csheen = mix(vec3(1.0f), Ctint, material.sheenTint); // Sheen Color
}

vec3 EvaluateDisneyDiffuse(Material material, BrdfData brdfData, vec3 Csheen, out float pdf)
{
	pdf = 0.0f;
	if (brdfData.NdotL <= 0.0f)
	{
		return vec3(0.0f);
	}

	float Rr = 2.0f * brdfData.LdotH * brdfData.LdotH * material.roughness;

	// Diffuse Fresnel - Go from 1 at normal incidence to 0.5 at grazing
	// and mix in diffuse retro-reflection based on roughness
    float Fd90 = 0.5f + Rr;
    float FL = SchlickFresnel(brdfData.NdotL);
    float FV = SchlickFresnel(brdfData.NdotV);
    float Fd = mix(1.0f, Fd90, FL) * mix(1.0f, Fd90, FV);

	// Subsurface Scattering - based on Hanrahan-Krueger BRDF approximation of isotropic bssrdf
	// 1.25 scale is used to (roughly) preserve albedo
	// Fss90 used to "flatten" retroreflection based on roughness
    float Fss90 = 0.5f * Rr;
    float Fss = mix(1.0f, Fss90, FL) * mix(1.0f, Fss90, FV);
    float ss = 1.25f * (Fss * (1.0f / (brdfData.NdotL + brdfData.NdotV) - 0.5f) + 0.5f);

	// Sheen
	float FH = SchlickFresnel(brdfData.LdotH);
	vec3 Fsheen = FH * material.sheenRoughness * Csheen;

	pdf = brdfData.NdotL * ONE_OVER_PI;
	return ONE_OVER_PI * material.albedo * mix(Fd, ss, material.subsurface) + Fsheen;
}

vec3 EvaluateMicrofacetReflection(Material material, BrdfData brdfData, vec3 F, out float pdf)
{
	pdf = 0.0f;
	if (brdfData.NdotL <= 0.0f)
	{
		return vec3(0.0f);
	}

	float D = GTR2_aniso(brdfData.NdotH, dot(brdfData.H, brdfData.X), dot(brdfData.H, brdfData.Y), brdfData.alphaAnisotropicX, brdfData.alphaAnisotropicY);
	float G1 = smithG_GGX_aniso(abs(brdfData.NdotV), dot(brdfData.V, brdfData.X), dot(brdfData.V, brdfData.Y), brdfData.alphaAnisotropicX, brdfData.alphaAnisotropicY);
	float G2 = G1 * smithG_GGX_aniso(abs(brdfData.NdotL), dot(brdfData.L, brdfData.X), dot(brdfData.L, brdfData.Y), brdfData.alphaAnisotropicX, brdfData.alphaAnisotropicY);

	pdf = G1 * D / (4.0f * brdfData.NdotV);
	return F * D * G2 / (4.0f * brdfData.NdotL * brdfData.NdotV);
}

vec3 EvaluateMicrofacetRefraction(Material material, BrdfData brdfData, vec3 F, out float pdf)
{
	pdf = 0.0f;
	if (brdfData.NdotL >= 0.0f)
	{
		return vec3(0.0f);
	}

	float D = GTR2_aniso(brdfData.NdotH, brdfData.HdotX, brdfData.HdotY, brdfData.alphaAnisotropicX, brdfData.alphaAnisotropicY);
	float G1 = smithG_GGX_aniso(abs(brdfData.NdotV), brdfData.VdotX, brdfData.VdotY, brdfData.alphaAnisotropicX, brdfData.alphaAnisotropicY);
	float G2 = G1 * smithG_GGX_aniso(abs(brdfData.NdotL), brdfData.LdotX, brdfData.LdotY, brdfData.alphaAnisotropicX, brdfData.alphaAnisotropicY);

	float denom = brdfData.LdotH + brdfData.VdotH * brdfData.incidentIor;
	denom *= denom;
	float eta2 = brdfData.incidentIor * brdfData.incidentIor;
	float jacobian = abs(brdfData.LdotH) / denom;

	pdf = G1 * max(0.0f, brdfData.VdotH) * D * jacobian / brdfData.NdotV;
	return pow(material.albedo, vec3(0.5f)) * (1.0f - F) * D * G2 * abs(brdfData.VdotH) * jacobian * eta2 / abs(brdfData.NdotL * brdfData.NdotV);
}

vec3 EvaluateClearcoat(Material material, BrdfData brdfData, out float pdf)
{
	pdf = 0.0f;
	if (brdfData.NdotL <= 0.0f)
	{
		return vec3(0.0f);
	}

    float F = mix(0.04f, 1.0f, SchlickFresnel(brdfData.VdotH));
	float D = GTR1(brdfData.NdotH, brdfData.alphaClearcoat);
    float G = smithG_GGX(brdfData.NdotL, 0.25f) * smithG_GGX(brdfData.NdotV, 0.25f);
	float jacobian = 1.0f / (4.0f * brdfData.VdotH);

	pdf = D * brdfData.NdotH * jacobian;
	return vec3(F) * D * G;
}

vec3 SampleDisneyBrdf(Material material, BrdfData brdfData, inout uint rngState)
{
	// Tint colors
	vec3 Csheen, Cspec0;
	TintColors(material, brdfData, Csheen, Cspec0);

	// Model weights
	float dielectricWeight = (1.0f - material.metallic) * (1.0f - material.transmission);
	float metalWeight = material.metallic;
	float glassWeight = (1.0f - material.metallic) * material.transmission;

	// Lobe probabilities
	float schlickWeight = SchlickFresnel(brdfData.NdotV);
	float diffuseProbability = dielectricWeight * Luminance(material.albedo);
	float dielectricProbability = dielectricWeight * Luminance(mix(Cspec0, vec3(1.0f), schlickWeight));
	float metalProbability = metalWeight * Luminance(mix(material.albedo, vec3(1.0f), schlickWeight));
	float glassProbability = glassWeight;
	float clearcoatProbability = 0.25f * material.clearcoat;

	// Normalize probabilities
	float invTotalWeight = 1.0f / (diffuseProbability + dielectricProbability + metalProbability + glassProbability + clearcoatProbability);
	diffuseProbability *= invTotalWeight;
	dielectricProbability *= invTotalWeight;
	metalProbability *= invTotalWeight;
	glassProbability *= invTotalWeight;
	clearcoatProbability *= invTotalWeight;

	// CDF of the sampling probabilities
	float cdf[5];
    cdf[0] = diffuseProbability;
    cdf[1] = cdf[0] + dielectricProbability;
    cdf[2] = cdf[1] + metalProbability;
    cdf[3] = cdf[2] + glassProbability;
    cdf[4] = cdf[3] + clearcoatProbability;

	// Sample Xi
	vec3 Xi = RandomValueVec3(rngState);

	// Sample a lobe based on its importance
	float rd = Xi.z;

	if (rd < cdf[0]) // Diffuse
	{
		vec3 H = HemispherepointCos(Xi.x, Xi.y);

		// To world
		H = ToWorld(brdfData.N, H);

		return H;
	}
	else if (rd < cdf[2]) // Dielectric + Metallic reflection
	{
		// Sample direction
		vec3 tangentV = ToLocal(brdfData.N, brdfData.V);
		vec3 H = SampleGGXVNDF(tangentV, brdfData.alphaAnisotropicX, brdfData.alphaAnisotropicY, Xi.xy);

		// Avoid scattered ray going into ground
		if (H.z < 0.0f)
			H = -H;

		// To world
		H = ToWorld(brdfData.N, H);

		return normalize(reflect(-brdfData.V, H));
	}
	else if (rd < cdf[3]) // Glass
	{
		// Sample direction
		vec3 tangentV = ToLocal(brdfData.N, brdfData.V);
		vec3 H = SampleGGXVNDF(tangentV, brdfData.alphaAnisotropicX, brdfData.alphaAnisotropicY, Xi.xy);

		// Avoid scattered ray going into ground
		if (H.z < 0.0f)
			H = -H;

		// To world
		H = ToWorld(brdfData.N, H);

		float F = DielectricFresnel(abs(dot(brdfData.V, H)), brdfData.incidentIor);

		// Rescale random number for reuse
		rd = (rd - cdf[2]) / (cdf[3] - cdf[2]);

		// Reflection
		if (rd < F)
		{
			return normalize(reflect(-brdfData.V, H));
		}
		else // Transmission
		{
			return normalize(refract(-brdfData.V, H, brdfData.incidentIor));
		}
	}
	else // Clearcoat
	{
		// Sample direction
		vec3 H = SampleGTR1(Xi.xy, brdfData.alphaClearcoat);

		// Avoid scattered ray going into ground
		if (H.z < 0.0f)
			H = -H;

		// To world
		H = ToWorld(brdfData.N, H);

		return normalize(reflect(-brdfData.V, H));
	}
}

// Based on: https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf
vec3 EvaluateDisneyBrdf(Material material, BrdfData brdfData, out float pdf)
{
	pdf = 0.0f;
	vec3 f = vec3(0.0f);

	// Tint colors
	vec3 Csheen, Cspec0;
	float F0 = brdfData.F0;
	TintColors(material, brdfData, Csheen, Cspec0);

	// Model weights
	float dielectricWeight = (1.0f - material.metallic) * (1.0f - material.transmission);
	float metalWeight = material.metallic;
	float glassWeight = (1.0f - material.metallic) * material.transmission;

	// Lobe probabilities
	float schlickWeight = SchlickFresnel(brdfData.NdotV);
	float diffuseProbability = dielectricWeight * Luminance(material.albedo);
	float dielectricProbability = dielectricWeight * Luminance(mix(Cspec0, vec3(1.0f), schlickWeight));
	float metalProbability = metalWeight * Luminance(mix(material.albedo, vec3(1.0f), schlickWeight));
	float glassProbability = glassWeight;
	float clearcoatProbability = 0.25f * material.clearcoat;

	// Normalize probabilities
	float invTotalWeight = 1.0f / (diffuseProbability + dielectricProbability + metalProbability + glassProbability + clearcoatProbability);
	diffuseProbability *= invTotalWeight;
	dielectricProbability *= invTotalWeight;
	metalProbability *= invTotalWeight;
	glassProbability *= invTotalWeight;
	clearcoatProbability *= invTotalWeight;

	bool reflection = brdfData.NdotL * brdfData.NdotV > 0.0f;

	float tmpPdf = 0.0f;
	float VdotH = abs(brdfData.VdotH);

	// Diffuse
	if (diffuseProbability > 0.0f && reflection)
	{
		f += EvaluateDisneyDiffuse(material, brdfData, Csheen, tmpPdf) * dielectricWeight;
		pdf += tmpPdf * diffuseProbability;
	}

	// Dielectric Reflection
	if (dielectricProbability > 0.0f && reflection)
	{
		// Normalize for interpolating based on Cspec0
		float F = (DielectricFresnel(VdotH, 1.0f / material.refraction) - F0) / (1.0f - F0);

		f += EvaluateMicrofacetReflection(material, brdfData, mix(Cspec0, vec3(1.0f), F), tmpPdf) * dielectricWeight;
		pdf += tmpPdf * dielectricProbability;
	}

	// Metallic reflection
	if (metalProbability > 0.0f && reflection)
	{
		// Tinted to albedo
		vec3 F = mix(material.albedo, vec3(1.0f), SchlickFresnel(VdotH));

		f += EvaluateMicrofacetReflection(material, brdfData, F, tmpPdf) * metalWeight;
		pdf += tmpPdf * metalProbability;
	}

	// Glass/Specular BSDF
	if (glassProbability > 0.0f)
	{
		// Dielectric fresnel (achromatic)
		float F = DielectricFresnel(VdotH, brdfData.incidentIor);

		if (reflection)
		{
			f += EvaluateMicrofacetReflection(material, brdfData, vec3(F), tmpPdf) * glassWeight;
			pdf += tmpPdf * glassProbability * F;
		}
		else
		{
			f += EvaluateMicrofacetRefraction(material, brdfData, vec3(F), tmpPdf) * glassWeight;
			pdf += tmpPdf * glassProbability * (1.0f - F);
		}
	}

	// Clearcoat
	if (clearcoatProbability > 0.0f && reflection)
	{
		f += EvaluateClearcoat(material, brdfData, tmpPdf) * 0.25f * material.clearcoat;
		pdf += tmpPdf * clearcoatProbability;
	}

	// Apply NdotL
	return f * abs(brdfData.NdotL);
}

// --------------------------------------------------------

vec2 GetSphericalCoord(vec3 V)
{
    vec2 uv = vec2(atan(V.z, V.x), asin(V.y));
    uv /= vec2(TWO_PI, PI);
    uv += 0.5;
    uv.y = 1.0 - uv.y;
    return uv;
}

// Sample from the precomputed HDRI cache
vec3 SampleHdri(inout uint rngState)
{
	// Sample Xi
	vec2 Xi = RandomValueVec2(rngState);

	vec2 uv = texture(sampler2D(environment.hdriCacheHandle), Xi).rg; // x, y
	uv.y = 1.0f - uv.y; // Flip

	// Get angle
	float phi = TWO_PI * (uv.x - 0.5f);	// [-pi ~ pi]
	float theta = PI * (uv.y - 0.5f);	// [-pi/2 ~ pi/2]

	// Calculate the direction in spherical coordinates
	vec3 L = vec3(cos(theta) * cos(phi), sin(theta), cos(theta) * sin(phi));

	return L;
}

// Get HDRI environment color
vec3 EvaluateHdri(vec3 L, out float pdf)
{
	vec3 color = vec3(0.0f);
	pdf = 0.0;

	vec2 uv = GetSphericalCoord(normalize(L));

	color = texture(sampler2D(environment.hdriHandle), uv).rgb;
	pdf = texture(sampler2D(environment.hdriCacheHandle), uv).b; // Sample probability density
	
	float theta = PI * (1.0f - uv.y); // 1.0f for full range...
	float sinTheta = max(sin(theta), 1e-10f);

	// Conversion factor between spherical coordinates and image integration domain
	float pConvert = environment.hdriDimensions.x * environment.hdriDimensions.y / (TWO_PI * PI * sinTheta);

	// Apply pdf conversion
	pdf *= pConvert;

	return color;
}

// Get HDRI environment color
vec3 GetHdriColor(vec3 L)
{
	vec2 uv = GetSphericalCoord(normalize(L));
	return texture(sampler2D(environment.hdriHandle), uv).rgb;
}

// --------------------------------------------------------

vec3 PathTrace(HitInfo primaryHit, Ray ray, inout uint rngState)
{
	HitInfo hitInfo = primaryHit;

	vec3 radiance	= vec3(0.0f); // Energy
	vec3 throughput	= vec3(1.0f); // Recursively accumulated color
	vec3 absorption = vec3(0.0f);

	const uint MaxBounceCount = 3;
	for (uint bounce = 0; bounce <= MaxBounceCount; bounce++)
	{
		vec3 V = -hitInfo.hitDirection;
		vec3 N = hitInfo.shadingNormal;
		float eta = dot(N, -V) < 0.0f ? (1.0f / hitInfo.material.refraction) : hitInfo.material.refraction;

		Material material = hitInfo.material;

		Ray hdriRay;
		hdriRay.origin = OffsetRay(hitInfo.hitPosition, hitInfo.geometryNormal);
		hdriRay.direction = SampleHdri(rngState);

		// Perform intersection test to check for occlusion
		if (dot(N, hdriRay.direction) > 0.0f)
		{
			// Cast shadow ray
			HitInfo hdriHitInfo = HitBvh(hdriRay);

			// Only continue light calculation if there is no occlusion toward light
			if (!hdriHitInfo.didHit)
			{
				// Sample light to get direction L
				vec3 L = hdriRay.direction;

				// Obtain light color and probability density for the direction L
				float pdfLight = 0.0f;
				vec3 colorLight = EvaluateHdri(L, pdfLight);

				// Prepare evaluation BRDF data
				BrdfData evaluationBrdfData = PrepareEvaluationBrdfData(material, V, N, L);

				// Obtain the BRDF value and probability density for the direction L
				float pdfBRDF = 0.0f;
				vec3 f = EvaluateDisneyBrdf(material, evaluationBrdfData, pdfBRDF);

				if (pdfBRDF > 0.0f)
				{
					// Multiple importance sampling
					float misWeight = misMixWeight(pdfLight, pdfBRDF);
					if (misWeight > 0.0f)
					{
						radiance += misWeight * throughput * colorLight * f / pdfLight;
					}
				}
			}
		}

		// Prepare sample BRDF data
		BrdfData samplingBrdfData = PrepareEvaluationBrdfData(material, V, N, vec3(0.0f));

		// Sample BRDF to get a direction L
		vec3 L = SampleDisneyBrdf(material, samplingBrdfData, rngState);

		// Prepare evaluation BRDF data
		BrdfData evaluationBrdfData = PrepareEvaluationBrdfData(material, V, N, L);

		// Obtain the BRDF value and probability density for the direction L
		float pdfBRDF = 0.0f;
		vec3 f = EvaluateDisneyBrdf(material, evaluationBrdfData, pdfBRDF);
		if (pdfBRDF <= 0.0f) break;

		// Emissive contribution
		vec3 emission = material.emission;
		radiance += throughput * emission * f / pdfBRDF;

		// Initialize ray of light
		ray.origin = OffsetRay(hitInfo.hitPosition, hitInfo.geometryNormal);
		ray.direction = L;
		hitInfo = HitBvh(ray);

		// Missed - HDRI light contribution
		if (!hitInfo.didHit)
		{
			float pdfLight = 0.0f;
			vec3 colorLight = EvaluateHdri(L, pdfLight);

			// Multiple importance sampling
			float misWeight = misMixWeight(pdfBRDF, pdfLight);
			if (misWeight > 0.0f)
			{
				// Indirect lighting rays are emitted according to BRDF distribution
				radiance += misWeight * throughput * colorLight * f / pdfBRDF;
			}

			break;
		}

		// Accumulate result
		throughput *= f / pdfBRDF;

		// Russian roulette
		// Random early exit if ray colour is nearly 0 (can't contribute much to final result)
		float p = max(throughput.r, max(throughput.g, throughput.b));
		if (RandomValue(rngState) >= p) 
		{
			break;
		}
		throughput *= 1.0f / p;
	}

	return radiance;
}

// --------------------------------------------------------

// Generate primary ray using pinhole camera
Ray GeneratePinholeCameraRay(vec2 uv)
{
	// Start from transformed position
	vec4 viewPos = InvProjMatrix * vec4(uv * 2.0f - 1.0f, 0.0f, 1.0f);
	vec3 origin = viewPos.xyz / viewPos.w;
	vec3 direction = normalize(origin); // Normalize to get view direction

	// Compute origin and direction based on view matrix
	Ray ray;
	ray.origin = (inverse(ViewMatrix) * vec4(origin, 1)).xyz;
	ray.direction = (inverse(ViewMatrix) * vec4(direction, 0)).xyz;

	return ray;
}

// Generate primary ray using thin lens model
Ray GenerateThinLensCameraRay(vec2 uv, inout uint rngState)
{
	// Extract camera vectors from view matrix
	vec3 cameraForward = -vec3(ViewMatrix[2][0], ViewMatrix[2][1], ViewMatrix[2][2]);
	vec3 cameraUp = vec3(ViewMatrix[1][0], ViewMatrix[1][1], ViewMatrix[1][2]);
	vec3 cameraRight = cross(cameraUp, cameraForward);

	// Find first point in distance at which we want perfect focus
	Ray ray = GeneratePinholeCameraRay(uv);
	vec3 focalPoint = ray.origin + ray.direction * FocalLength;

	// Sample aperture shape
	vec2 apertureSample = HemispherepointCos(RandomValue(rngState), RandomValue(rngState)).xy * ApertureShape * ApertureSize;

	// Jitter the ray origin within camera plane using aperture sample	
	ray.origin = ray.origin + cameraRight * apertureSample.x + cameraUp * apertureSample.y;

	// Set ray direction from jittered origin towards the focal point
	ray.direction = normalize(focalPoint - ray.origin);

	return ray;
}

// Generates primary ray using either pinhole or thin lens model
Ray GeneratePrimaryRay(vec2 uv, inout uint rngState)
{
	if (ApertureSize == 0.0f)
	{
		return GeneratePinholeCameraRay(uv);
	}
	else
	{
		return GenerateThinLensCameraRay(uv, rngState);
	}
}

// --------------------------------------------------------

// Debug HDRI Cache: Draw red dots on important sources of light
vec4 DebugHdriCache(vec2 uv)
{
	vec3 hdriColor = texture(sampler2D(environment.hdriHandle), vec2(uv.x, -uv.y)).rgb;

    // Sample points
    for(uint i = 0u; i < 500u; i++)
	{
		uint XiState = i;
		vec2 Xi = RandomValueVec2(XiState);

        vec2 texcoord = texture(sampler2D(environment.hdriCacheHandle), Xi).rg;
        texcoord.y = 1.0f - texcoord.y;

		// Mark areas red that follow HDRI cache
        if(distance(uv, texcoord) < 0.005f)
		{
			hdriColor = vec3(1.0f, 0.0f, 0.0f);
		}
    }

	return vec4(hdriColor, 1.0f);
}

// Debug BVH: Count BVH node intersections on a given ray
vec4 DebugBvh(Ray debugRay)
{
	vec3 bvhColor = HitBvhDebug(debugRay);
	return vec4(bvhColor, 1.0f);
}

// Choose debug output function
vec4 DebugOutput(vec2 uv, Ray debugRay)
{
#if defined(DEBUG_HDRI_CACHE)
	return DebugHdriCache(uv);
#elif defined(DEBUG_BVH)
	return DebugBvh(debugRay);
#endif
	return vec4(0.0f);
}

// --------------------------------------------------------

void main()
{
	// Initialize pixel coordinate information
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (texelCoord + 0.5f) / FrameDimensions;

	// Initialize rng state
	uint pixelIndex = texelCoord.y * uint(FrameDimensions.x) + texelCoord.x;
	uint rngState = pixelIndex + FrameCount * 719393;

	// Debug: Output meaningful data for analysis
#if defined(DEBUG_ENABLED)
	Ray debugRay = GeneratePinholeCameraRay(uv);
	vec4 debugValue = DebugOutput(uv, debugRay);

	imageStore(imgOutput, texelCoord, debugValue);
	return;
#endif

	// Apply Anti-Aliasing
	if (bool(AntiAliasingEnabled))
	{
		// Apply random offset in the range [-0.5, 0.5] pixels
		vec2 offset = RandomValueVec2(rngState);
		uv += (offset - 0.5f) / vec2(FrameDimensions);
	}

	// Initialize primary ray
	Ray ray = GeneratePrimaryRay(uv, rngState);

	// Generate primary hit information
	HitInfo primaryHit = HitBvh(ray);

	vec3 radianceResult = vec3(0.0f);
	vec3 primaryAlbedoResult = vec3(0.0f);
	vec3 primaryNormalResult = vec3(0.0f);

	// No reason to trace if we hit background the first time
	if (!primaryHit.didHit)
	{
		// Sample HDRI
		vec3 L = ray.direction;
		radianceResult = GetHdriColor(L);
	}
	else
	{
		// PathTrace 
		radianceResult = PathTrace(primaryHit, ray, rngState);

		// Fetch denoiser essentials
		primaryAlbedoResult = primaryHit.material.albedo;
		primaryNormalResult = primaryHit.shadingNormal;
	}
	
	// Temporal accumulation. Weigh the contributions to result in an average over all frames.
	float weight = 1.0f / FrameCount;

	// Radiance accumulation
	vec4 previousRadiance = imageLoad(radianceImage, texelCoord);
	vec4 accumulatedRadiance = mix(previousRadiance, vec4(radianceResult, 1.0f), weight);
	
	// Primary Albedo accumulation
	vec4 previousPrimaryAlbedo = imageLoad(primaryAlbedoImage, texelCoord);
	vec4 accumulatedPrimaryAlbedo = mix(previousPrimaryAlbedo, vec4(primaryAlbedoResult, 1.0f), weight);
	
	// Primary Normal accumulation
	vec4 previousPrimaryNormal = imageLoad(primaryNormalImage, texelCoord);
	vec4 accumulatedPrimaryNormal = mix(previousPrimaryNormal, vec4(primaryNormalResult, 1.0f), weight);

	// Output
	imageStore(radianceImage, texelCoord, accumulatedRadiance);
	imageStore(primaryAlbedoImage, texelCoord, accumulatedPrimaryAlbedo);
	imageStore(primaryNormalImage, texelCoord, accumulatedPrimaryNormal);
}
